<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>src.problem.problem API documentation</title>
<meta name="description" content="最適化問題に関する module">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.problem.problem</code></h1>
</header>
<section id="section-intro">
<p>最適化問題に関する module</p>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.problem.problem.LinearProgrammingProblem"><code class="flex name class">
<span>class <span class="ident">LinearProgrammingProblem</span></span>
<span>(</span><span>A_E: np.ndarray, b_E: np.ndarray, A_G: np.ndarray, b_G: np.ndarray, A_L: np.ndarray, b_L: np.ndarray, LB_index: list[int], LB: np.ndarray, UB_index: list[int], UB: np.ndarray, c: np.ndarray, name: str = '')</span>
</code></dt>
<dd>
<div class="desc"><p>線形計画問題に関するクラス</p>
<p>以下の問題について定数を格納する
min c.T @ x
s.t.
A_E @ x = b_E
A_G @ x &gt;= b_G
A_L @ x &lt;= b_L
x[LB_index] &gt;= LB
x[UB_index] &lt;= UB</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>LB_index</code></strong></dt>
<dd>変数の下限が存在する場合のその添え字リスト.
変数の下限が存在しない場合もあるため index を指定する必要がある</dd>
<dt><strong><code>LB</code></strong></dt>
<dd>変数の下限. LO_index 通りにソートされている</dd>
<dt><strong><code>UB_index</code></strong></dt>
<dd>変数の上限が存在する場合のその添え字リスト.
変数の上限が存在しない場合もあるため index を指定する必要がある</dd>
<dt><strong><code>UB</code></strong></dt>
<dd>変数の上限. UP_index 通りにソートされている</dd>
<dt><strong><code>name</code></strong></dt>
<dd>問題名. デフォルトは空白</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclasses.dataclass
class LinearProgrammingProblem:
    &#34;&#34;&#34;線形計画問題に関するクラス

    以下の問題について定数を格納する
    min c.T @ x
    s.t.
        A_E @ x = b_E
        A_G @ x &gt;= b_G
        A_L @ x &lt;= b_L
        x[LB_index] &gt;= LB
        x[UB_index] &lt;= UB

    Args:
        LB_index: 変数の下限が存在する場合のその添え字リスト.
            変数の下限が存在しない場合もあるため index を指定する必要がある
        LB: 変数の下限. LO_index 通りにソートされている
        UB_index: 変数の上限が存在する場合のその添え字リスト.
            変数の上限が存在しない場合もあるため index を指定する必要がある
        UB: 変数の上限. UP_index 通りにソートされている
        name: 問題名. デフォルトは空白
    &#34;&#34;&#34;
    A_E: np.ndarray
    b_E: np.ndarray
    A_G: np.ndarray
    b_G: np.ndarray
    A_L: np.ndarray
    b_L: np.ndarray
    LB_index: list[int]
    LB: np.ndarray
    UB_index: list[int]
    UB: np.ndarray
    c: np.ndarray
    name: str = &#34;&#34;

    @property
    def n(self):
        &#34;&#34;&#34;変数の次元数

        A_* が空行列となる場合があるため, c の次元から取得
        &#34;&#34;&#34;
        return self.c.shape[0]

    def __eq__(self, other: object) -&gt; bool:
        &#34;&#34;&#34;要素が `np.array` なので, 標準の __eq__ メソッドだとエラーになる

        TODO:
            * LB, UB でも判定するようにする
        &#34;&#34;&#34;
        is_same_A_E = np.array_equal(self.A_E, other.A_E)
        is_same_b_E = np.array_equal(self.b_E, other.b_E)
        is_same_A_G = np.array_equal(self.A_G, other.A_G)
        is_same_b_G = np.array_equal(self.b_G, other.b_G)
        is_same_A_L = np.array_equal(self.A_L, other.A_L)
        is_same_b_L = np.array_equal(self.b_L, other.b_L)
        is_same_A = is_same_A_E and is_same_A_G and is_same_A_L
        is_same_b = is_same_b_E and is_same_b_G and is_same_b_L
        is_same_c = np.array_equal(self.c, other.c)
        return is_same_A and is_same_b and is_same_c

    # 以下、標準系に修正するための処理
    # データが入っていなくても実行可能なため classmethod
    @classmethod
    def reverse_non_lower_bound(
        cls, lb: np.ndarray, ub: np.ndarray,
        A: np.ndarray, c: np.ndarray
    ) -&gt; tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]:
        &#34;&#34;&#34;変数の下限が存在せず, 上限が存在する場合, 対応する変数の添え字の符号を反転させる

        Args:
            lb: 変数の下限. 下限がない次元は -inf
            ub: 変数の上限. 上限がない次元は inf
            A: A
            c: c

        Returns:
            np.ndarray: 変数の lower bound
            np.ndarray: 変数の upper bound
            np.ndarray: A. のちにどの制約かによって区分けするが, ここでの出力はひとまとめにしたもの
            np.ndarray: c
        &#34;&#34;&#34;
        # 下限が存在せず, 上限が存在する添え字の取得
        id_lb_inf = np.where(lb == -np.inf)[0]
        id_ub_non_inf = np.where(ub != np.inf)[0]
        indexes = list(set(id_lb_inf) &amp; set(id_ub_non_inf))

        # 対象の添え字の符号を反転する
        lb_out = lb.copy()
        ub_out = ub.copy()
        lb_out[indexes], ub_out[indexes] = -ub[indexes], -lb[indexes]
        A_out = A.copy()
        A_out[:, indexes] = -A[:, indexes]
        c_out = c.copy()
        c_out[indexes] = -c[indexes]
        return lb_out, ub_out, A_out, c_out

    @classmethod
    def separate_free_variable(
        cls, lb: np.ndarray, ub: np.ndarray, A: np.ndarray, c: np.ndarray
    ) -&gt; tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]:
        &#34;&#34;&#34;変数に下限も上限もない自由変数の場合, 新しい変数列を作成して正の部分と負の部分に分ける

        正部分に関する変数は同じ場所に残し, 負部分に関する変数は末尾に追加する
        正部分は, 下限を0に変更するのみ
        負部分は, 下限0, 上限inf, -A_{正部分}, c_{正部分} をそれぞれ追加する

        Args:
            lb: 変数の下限. 下限がない次元は -inf
            ub: 変数の上限. 上限がない次元は inf
            A: A
            c: c

        Returns:
            np.ndarray: 変数の lower bound
            np.ndarray: 変数の upper bound
            np.ndarray: A
            np.ndarray: c
        &#34;&#34;&#34;
        # 自由変数の添え字の取得
        id_lb_inf = np.where(lb == -np.inf)[0]
        id_ub_non_inf = np.where(ub == np.inf)[0]
        indexes = list(set(id_lb_inf) &amp; set(id_ub_non_inf))
        # 出力を入力からコピー. このインスタンスに追加する
        lb_out = lb.copy()
        ub_out = ub.copy()
        A_out = A.copy()
        c_out = c.copy()
        # Aに列追加する際に reshape が必要なので, 行数を取っておく
        m = A.shape[0]

        # 各自由変数ごとに追加する
        for id_ in indexes:
            # 正部分の添え字
            lb_out[id_] = 0
            # 負部分の添え字（追加）
            lb_out = np.append(lb_out, 0)
            ub_out = np.append(ub_out, np.inf)
            A_out = np.concatenate([A_out, -A[:, id_].reshape(m, 1)], axis=1)
            c_out = np.append(c_out, -c[id_])
        return lb_out, ub_out, A_out, c_out

    @classmethod
    def make_standard_A(
        cls, A_E: np.ndarray, A_G: np.ndarray, A_L: np.ndarray, ub: np.ndarray
    ) -&gt; np.ndarray:
        &#34;&#34;&#34;等式制約, 不等式制約から標準形式の係数行列を作成する

        Args:
            A_E: 等式制約に関する係数行列
            A_G: 下限制約に関する係数行列
            A_L: 上限制約に関する係数行列
            ub: 変数の上限. 上限が存在しない次元は inf
        &#34;&#34;&#34;
        lst_index_up = np.where(ub != np.inf)[0]

        # 各次元取得
        n = A_E.shape[1]
        m_e = A_E.shape[0]
        m_g = A_G.shape[0]
        m_l = A_L.shape[0]
        m_b = len(lst_index_up)

        # box constraint に関する単位行列を作成
        A_B = np.zeros([m_b, n])
        for i, index_up in enumerate(lst_index_up):
            A_B[i, index_up] = 1

        # 組み合わせて一つの行列に
        output = np.concatenate([
            np.concatenate([A_E, np.zeros([m_e, m_g + m_l + m_b])], 1),
            np.concatenate([A_G, -np.eye(m_g), np.zeros([m_g, m_l + m_b])], 1),
            np.concatenate(
                [A_L, np.zeros([m_l, m_g]), np.eye(m_l), np.zeros([m_l, m_b])],
                1
            ),
            np.concatenate([A_B, np.zeros([m_b, m_g + m_l]), np.eye(m_b)], 1)
        ])
        return output

    @classmethod
    def make_standard_b(
        cls, A_E, A_G, A_L, b_E, b_G, b_L, lb, ub
    ) -&gt; np.ndarray:
        &#34;&#34;&#34;等式制約, 不等式制約から標準形式の right hand side を作成する

        Args:
            A_E: 等式制約に関する係数行列
            A_G: 下限制約に関する係数行列
            A_L: 上限制約に関する係数行列
            b_E: 等式制約に関する右辺
            b_G: 下限制約に関する右辺
            b_L: 上限制約に関する右辺
            lb: 変数の下限値
            ub: 変数の上限値. inf であれば上限を設定する必要がない
        &#34;&#34;&#34;
        lst_index_up = np.where(ub != np.inf)[0]

        b = np.concatenate([
            b_E - A_E @ lb,
            b_G - A_G @ lb,
            b_L - A_L @ lb,
            ub[lst_index_up] - lb[lst_index_up]
        ])
        return b

    @classmethod
    def make_standard_c(
        cls, c: np.ndarray, m_GL: int, ub: np.ndarray
    ) -&gt; np.ndarray:
        &#34;&#34;&#34;不等式制約から標準形式の目的関数係数を作成する

        Args:
            c: c
            m_GL: 上限, 下限不等式制約の数を合わせた数
            ub: 変数の上限. 上限が存在しない次元は inf
        &#34;&#34;&#34;
        m_B = len(np.where(ub != np.inf)[0])
        return np.concatenate([c, np.zeros(m_GL + m_B)])

    def convert_standard(self) -&gt; LinearProgrammingProblemStandard:
        &#34;&#34;&#34;等式制約のみの標準形線形計画問題に修正する&#34;&#34;&#34;
        # 変数の正負, 自由変数において変更があるため A はまとめておく
        A = np.concatenate([self.A_E, self.A_G, self.A_L])

        # 変数の上下限が存在しない箇所は発散させておく
        lb = np.full(self.n, -np.inf)
        lb[self.LB_index] = self.LB
        ub = np.full(self.n, np.inf)
        ub[self.UB_index] = self.UB

        # 変数すべてに下限を設定
        lb_tmp, ub_tmp, A_tmp, c_tmp = self.separate_free_variable(
            *self.reverse_non_lower_bound(lb, ub, A, self.c)
        )
        # 等式制約に統一するため不等式制約を別々にする
        m_e = self.A_E.shape[0]
        m_g = self.A_G.shape[0]
        m_l = self.A_L.shape[0]
        A_E = A_tmp[range(m_e), :]
        A_G = A_tmp[range(m_e, m_e + m_g), :]
        m_gl = m_g + m_l
        A_L = A_tmp[range(m_e + m_g, m_e + m_gl), :]

        # 変形して標準形式の A, b, c 作成
        A_out = self.make_standard_A(A_E, A_G, A_L, ub_tmp)
        b_out = self.make_standard_b(
            A_E, A_G, A_L, self.b_E, self.b_G, self.b_L, lb_tmp, ub_tmp
        )
        c_out = self.make_standard_c(c_tmp, m_gl, ub_tmp)

        return LinearProgrammingProblemStandard(A_out, b_out, c_out, self.name)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="src.problem.problem.LinearProgrammingProblem.A_E"><code class="name">var <span class="ident">A_E</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.problem.problem.LinearProgrammingProblem.A_G"><code class="name">var <span class="ident">A_G</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.problem.problem.LinearProgrammingProblem.A_L"><code class="name">var <span class="ident">A_L</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.problem.problem.LinearProgrammingProblem.LB"><code class="name">var <span class="ident">LB</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.problem.problem.LinearProgrammingProblem.LB_index"><code class="name">var <span class="ident">LB_index</span> : list[int]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.problem.problem.LinearProgrammingProblem.UB"><code class="name">var <span class="ident">UB</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.problem.problem.LinearProgrammingProblem.UB_index"><code class="name">var <span class="ident">UB_index</span> : list[int]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.problem.problem.LinearProgrammingProblem.b_E"><code class="name">var <span class="ident">b_E</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.problem.problem.LinearProgrammingProblem.b_G"><code class="name">var <span class="ident">b_G</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.problem.problem.LinearProgrammingProblem.b_L"><code class="name">var <span class="ident">b_L</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.problem.problem.LinearProgrammingProblem.c"><code class="name">var <span class="ident">c</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.problem.problem.LinearProgrammingProblem.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="src.problem.problem.LinearProgrammingProblem.make_standard_A"><code class="name flex">
<span>def <span class="ident">make_standard_A</span></span>(<span>A_E: np.ndarray, A_G: np.ndarray, A_L: np.ndarray, ub: np.ndarray) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>等式制約, 不等式制約から標準形式の係数行列を作成する</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>A_E</code></strong></dt>
<dd>等式制約に関する係数行列</dd>
<dt><strong><code>A_G</code></strong></dt>
<dd>下限制約に関する係数行列</dd>
<dt><strong><code>A_L</code></strong></dt>
<dd>上限制約に関する係数行列</dd>
<dt><strong><code>ub</code></strong></dt>
<dd>変数の上限. 上限が存在しない次元は inf</dd>
</dl></div>
</dd>
<dt id="src.problem.problem.LinearProgrammingProblem.make_standard_b"><code class="name flex">
<span>def <span class="ident">make_standard_b</span></span>(<span>A_E, A_G, A_L, b_E, b_G, b_L, lb, ub) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>等式制約, 不等式制約から標準形式の right hand side を作成する</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>A_E</code></strong></dt>
<dd>等式制約に関する係数行列</dd>
<dt><strong><code>A_G</code></strong></dt>
<dd>下限制約に関する係数行列</dd>
<dt><strong><code>A_L</code></strong></dt>
<dd>上限制約に関する係数行列</dd>
<dt><strong><code>b_E</code></strong></dt>
<dd>等式制約に関する右辺</dd>
<dt><strong><code>b_G</code></strong></dt>
<dd>下限制約に関する右辺</dd>
<dt><strong><code>b_L</code></strong></dt>
<dd>上限制約に関する右辺</dd>
<dt><strong><code>lb</code></strong></dt>
<dd>変数の下限値</dd>
<dt><strong><code>ub</code></strong></dt>
<dd>変数の上限値. inf であれば上限を設定する必要がない</dd>
</dl></div>
</dd>
<dt id="src.problem.problem.LinearProgrammingProblem.make_standard_c"><code class="name flex">
<span>def <span class="ident">make_standard_c</span></span>(<span>c: np.ndarray, m_GL: int, ub: np.ndarray) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>不等式制約から標準形式の目的関数係数を作成する</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>c</code></strong></dt>
<dd>c</dd>
<dt><strong><code>m_GL</code></strong></dt>
<dd>上限, 下限不等式制約の数を合わせた数</dd>
<dt><strong><code>ub</code></strong></dt>
<dd>変数の上限. 上限が存在しない次元は inf</dd>
</dl></div>
</dd>
<dt id="src.problem.problem.LinearProgrammingProblem.reverse_non_lower_bound"><code class="name flex">
<span>def <span class="ident">reverse_non_lower_bound</span></span>(<span>lb: np.ndarray, ub: np.ndarray, A: np.ndarray, c: np.ndarray) ‑> tuple[numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>変数の下限が存在せず, 上限が存在する場合, 対応する変数の添え字の符号を反転させる</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>lb</code></strong></dt>
<dd>変数の下限. 下限がない次元は -inf</dd>
<dt><strong><code>ub</code></strong></dt>
<dd>変数の上限. 上限がない次元は inf</dd>
<dt><strong><code>A</code></strong></dt>
<dd>A</dd>
<dt><strong><code>c</code></strong></dt>
<dd>c</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>変数の lower bound</dd>
<dt><code>np.ndarray</code></dt>
<dd>変数の upper bound</dd>
<dt><code>np.ndarray</code></dt>
<dd>A. のちにどの制約かによって区分けするが, ここでの出力はひとまとめにしたもの</dd>
<dt><code>np.ndarray</code></dt>
<dd>c</dd>
</dl></div>
</dd>
<dt id="src.problem.problem.LinearProgrammingProblem.separate_free_variable"><code class="name flex">
<span>def <span class="ident">separate_free_variable</span></span>(<span>lb: np.ndarray, ub: np.ndarray, A: np.ndarray, c: np.ndarray) ‑> tuple[numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>変数に下限も上限もない自由変数の場合, 新しい変数列を作成して正の部分と負の部分に分ける</p>
<p>正部分に関する変数は同じ場所に残し, 負部分に関する変数は末尾に追加する
正部分は, 下限を0に変更するのみ
負部分は, 下限0, 上限inf, -A_{正部分}, c_{正部分} をそれぞれ追加する</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>lb</code></strong></dt>
<dd>変数の下限. 下限がない次元は -inf</dd>
<dt><strong><code>ub</code></strong></dt>
<dd>変数の上限. 上限がない次元は inf</dd>
<dt><strong><code>A</code></strong></dt>
<dd>A</dd>
<dt><strong><code>c</code></strong></dt>
<dd>c</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>変数の lower bound</dd>
<dt><code>np.ndarray</code></dt>
<dd>変数の upper bound</dd>
<dt><code>np.ndarray</code></dt>
<dd>A</dd>
<dt><code>np.ndarray</code></dt>
<dd>c</dd>
</dl></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="src.problem.problem.LinearProgrammingProblem.n"><code class="name">prop <span class="ident">n</span></code></dt>
<dd>
<div class="desc"><p>変数の次元数</p>
<p>A_* が空行列となる場合があるため, c の次元から取得</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n(self):
    &#34;&#34;&#34;変数の次元数

    A_* が空行列となる場合があるため, c の次元から取得
    &#34;&#34;&#34;
    return self.c.shape[0]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="src.problem.problem.LinearProgrammingProblem.convert_standard"><code class="name flex">
<span>def <span class="ident">convert_standard</span></span>(<span>self) ‑> <a title="src.problem.problem.LinearProgrammingProblemStandard" href="#src.problem.problem.LinearProgrammingProblemStandard">LinearProgrammingProblemStandard</a></span>
</code></dt>
<dd>
<div class="desc"><p>等式制約のみの標準形線形計画問題に修正する</p></div>
</dd>
</dl>
</dd>
<dt id="src.problem.problem.LinearProgrammingProblemStandard"><code class="flex name class">
<span>class <span class="ident">LinearProgrammingProblemStandard</span></span>
<span>(</span><span>A: np.ndarray, b: np.ndarray, c: np.ndarray, name: str = '')</span>
</code></dt>
<dd>
<div class="desc"><p>標準形の線形計画問題に関するクラス</p>
<p>以下の問題について定数を格納する
min c.T @ x
s.t.
A @ x = b
x &gt;= 0</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>問題名. デフォルトは空白</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclasses.dataclass
class LinearProgrammingProblemStandard:
    &#34;&#34;&#34;標準形の線形計画問題に関するクラス

    以下の問題について定数を格納する
    min c.T @ x
    s.t.
        A @ x = b
        x &gt;= 0

    Args:
        name: 問題名. デフォルトは空白
    &#34;&#34;&#34;
    A: np.ndarray
    b: np.ndarray
    c: np.ndarray
    name: str = &#34;&#34;

    @property
    def n(self):
        &#34;&#34;&#34;変数の次元数&#34;&#34;&#34;
        return self.A.shape[1]

    @property
    def m(self):
        &#34;&#34;&#34;制約の数&#34;&#34;&#34;
        return self.A.shape[0]

    def __post_init__(self):
        &#34;&#34;&#34;設定された定数の次元が正しいか確認し, 正しくなければエラーを返す&#34;&#34;&#34;
        m = self.m
        if (dim_b := self.b.shape[0]) != m:
            msg = f&#34;制約の次元数が異なります. Aの行数 : {m}, bの次元 : {dim_b}&#34;
            raise SettingProblemError(msg)
        n = self.n
        if (dim_c := self.c.shape[0]) != n:
            msg = f&#34;目的関数の次元数が異なります. Aの列数 : {n}, cの次元 : {dim_c}&#34;
            raise SettingProblemError(msg)

    def __eq__(self, other: object) -&gt; bool:
        &#34;&#34;&#34;要素が `np.array` なので, 標準の __eq__ メソッドだとエラーになる&#34;&#34;&#34;
        is_same_A = np.array_equal(self.A, other.A)
        is_same_b = np.array_equal(self.b, other.b)
        is_same_c = np.array_equal(self.c, other.c)
        return is_same_A and is_same_b and is_same_c

    @property
    def max_abs_A(self) -&gt; float:
        &#34;&#34;&#34;A の係数のうち最大の絶対値を出力&#34;&#34;&#34;
        return np.abs(self.A).max()

    @property
    def min_abs_A_nonzero(self) -&gt; float:
        &#34;&#34;&#34;A の係数のうち最小の絶対値(0は除く)を出力
        &#34;&#34;&#34;
        return np.abs(self.A[self.A != 0]).min()

    @property
    def condition_number_A(self) -&gt; float:
        return np.linalg.cond(self.A)

    @property
    def max_sqrt_eigen_value_AAT(self) -&gt; float:
        eig_val, _ = np.linalg.eig(self.A @ self.A.T)
        return np.max(np.sqrt(eig_val))

    @property
    def min_sqrt_eigen_value_AAT(self) -&gt; float:
        eig_val, _ = np.linalg.eig(self.A @ self.A.T)
        return np.min(np.sqrt(eig_val))

    def is_full_row_rank(self) -&gt; bool:
        &#34;&#34;&#34;制約行列 A が full row rank かを出力

        Returns:
            bool: A が full row rank であれば true
        &#34;&#34;&#34;
        return np.linalg.matrix_rank(self.A) == self.m

    def objective_main(self, x: np.ndarray) -&gt; float:
        &#34;&#34;&#34;主問題の目的関数値の出力&#34;&#34;&#34;
        return self.c.T @ x

    def objective_dual(self, y: np.ndarray) -&gt; float:
        &#34;&#34;&#34;双対問題の目的関数値の出力&#34;&#34;&#34;
        return self.b.T @ y

    def residual_main_constraint(self, x: np.ndarray) -&gt; np.ndarray:
        &#34;&#34;&#34;主問題の制約に対する残渣ベクトルの出力&#34;&#34;&#34;
        return self.A @ x - self.b

    def residual_dual_constraint(
        self, y: np.ndarray, s: np.ndarray
    ) -&gt; np.ndarray:
        &#34;&#34;&#34;双対問題の制約に対する残渣ベクトルの出力&#34;&#34;&#34;
        return self.A.T @ y + s - self.c

    # このメソッドは最適解自体を変えてしまうので削除
    # def create_A_row_normalized(self) -&gt; LinearProgrammingProblemStandard:
    #     &#34;&#34;&#34;A の各行のノルムを 1 に正規化した問題を出力

    #     Returns:
    #         LinearProgrammingProblemStandard: 正規化された問題
    #     &#34;&#34;&#34;
    #     norm_each_row_A = np.linalg.norm(self.A, axis=1)
    #     return LinearProgrammingProblemStandard(self.A / norm_each_row_A[:, None], self.b / norm_each_row_A, self.c, self.name)

    def create_A_LU_factorized(self) -&gt; tuple[LinearProgrammingProblemStandard, list[int]]:
        &#34;&#34;&#34;A をLU分解した問題を出力
        Uの対角成分が0の場合, bの対応する行がすべて0であれば, その行をすべて削除して問題サイズを小さくする
        もし0でなければ実行不可能としてエラーを吐く

        Returns:
            LinearProgrammingProblemStandard: A=U, b=(PL)^(-1) とした問題.
                U の対角成分が0の行は抜いてある
            list[int]: もしUの対角成分が0だった場合にどの行が対象になったかを表す list
        &#34;&#34;&#34;
        P, L, U = scipy.linalg.lu(self.A)
        b_factorized = np.linalg.inv(P) @ np.linalg.inv(L) @ self.b

        # U の対角成分が0の行を記録
        idx_zero_diag_element: list[int] = []
        for i in range(self.m):
            if np.all(np.isclose(U[i, :], 0)):
                if not np.isclose(b_factorized[i], 0):
                    raise SettingProblemError(f&#34;{i}行目において数値誤差を凌駕するほど実行不可能. U_i: {U[i, :]}, b_i: {b_factorized[i]}&#34;)
                idx_zero_diag_element.append(i)

        # 指定された行を省いて出力
        idx_leave_row = np.ones(self.m, dtype=bool)
        idx_leave_row[idx_zero_diag_element] = False
        A_new = U[idx_leave_row, :]
        b_new = b_factorized[idx_leave_row]

        return LinearProgrammingProblemStandard(A_new, b_new, self.c, self.name), idx_zero_diag_element</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="src.problem.problem.LinearProgrammingProblemStandard.A"><code class="name">var <span class="ident">A</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.problem.problem.LinearProgrammingProblemStandard.b"><code class="name">var <span class="ident">b</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.problem.problem.LinearProgrammingProblemStandard.c"><code class="name">var <span class="ident">c</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.problem.problem.LinearProgrammingProblemStandard.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="src.problem.problem.LinearProgrammingProblemStandard.condition_number_A"><code class="name">prop <span class="ident">condition_number_A</span> : float</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def condition_number_A(self) -&gt; float:
    return np.linalg.cond(self.A)</code></pre>
</details>
</dd>
<dt id="src.problem.problem.LinearProgrammingProblemStandard.m"><code class="name">prop <span class="ident">m</span></code></dt>
<dd>
<div class="desc"><p>制約の数</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def m(self):
    &#34;&#34;&#34;制約の数&#34;&#34;&#34;
    return self.A.shape[0]</code></pre>
</details>
</dd>
<dt id="src.problem.problem.LinearProgrammingProblemStandard.max_abs_A"><code class="name">prop <span class="ident">max_abs_A</span> : float</code></dt>
<dd>
<div class="desc"><p>A の係数のうち最大の絶対値を出力</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def max_abs_A(self) -&gt; float:
    &#34;&#34;&#34;A の係数のうち最大の絶対値を出力&#34;&#34;&#34;
    return np.abs(self.A).max()</code></pre>
</details>
</dd>
<dt id="src.problem.problem.LinearProgrammingProblemStandard.max_sqrt_eigen_value_AAT"><code class="name">prop <span class="ident">max_sqrt_eigen_value_AAT</span> : float</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def max_sqrt_eigen_value_AAT(self) -&gt; float:
    eig_val, _ = np.linalg.eig(self.A @ self.A.T)
    return np.max(np.sqrt(eig_val))</code></pre>
</details>
</dd>
<dt id="src.problem.problem.LinearProgrammingProblemStandard.min_abs_A_nonzero"><code class="name">prop <span class="ident">min_abs_A_nonzero</span> : float</code></dt>
<dd>
<div class="desc"><p>A の係数のうち最小の絶対値(0は除く)を出力</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def min_abs_A_nonzero(self) -&gt; float:
    &#34;&#34;&#34;A の係数のうち最小の絶対値(0は除く)を出力
    &#34;&#34;&#34;
    return np.abs(self.A[self.A != 0]).min()</code></pre>
</details>
</dd>
<dt id="src.problem.problem.LinearProgrammingProblemStandard.min_sqrt_eigen_value_AAT"><code class="name">prop <span class="ident">min_sqrt_eigen_value_AAT</span> : float</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def min_sqrt_eigen_value_AAT(self) -&gt; float:
    eig_val, _ = np.linalg.eig(self.A @ self.A.T)
    return np.min(np.sqrt(eig_val))</code></pre>
</details>
</dd>
<dt id="src.problem.problem.LinearProgrammingProblemStandard.n"><code class="name">prop <span class="ident">n</span></code></dt>
<dd>
<div class="desc"><p>変数の次元数</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n(self):
    &#34;&#34;&#34;変数の次元数&#34;&#34;&#34;
    return self.A.shape[1]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="src.problem.problem.LinearProgrammingProblemStandard.create_A_LU_factorized"><code class="name flex">
<span>def <span class="ident">create_A_LU_factorized</span></span>(<span>self) ‑> tuple[<a title="src.problem.problem.LinearProgrammingProblemStandard" href="#src.problem.problem.LinearProgrammingProblemStandard">LinearProgrammingProblemStandard</a>, list[int]]</span>
</code></dt>
<dd>
<div class="desc"><p>A をLU分解した問題を出力
Uの対角成分が0の場合, bの対応する行がすべて0であれば, その行をすべて削除して問題サイズを小さくする
もし0でなければ実行不可能としてエラーを吐く</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="src.problem.problem.LinearProgrammingProblemStandard" href="#src.problem.problem.LinearProgrammingProblemStandard">LinearProgrammingProblemStandard</a></code></dt>
<dd>A=U, b=(PL)^(-1) とした問題.
U の対角成分が0の行は抜いてある</dd>
<dt><code>list[int]</code></dt>
<dd>もしUの対角成分が0だった場合にどの行が対象になったかを表す list</dd>
</dl></div>
</dd>
<dt id="src.problem.problem.LinearProgrammingProblemStandard.is_full_row_rank"><code class="name flex">
<span>def <span class="ident">is_full_row_rank</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>制約行列 A が full row rank かを出力</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>A が full row rank であれば true</dd>
</dl></div>
</dd>
<dt id="src.problem.problem.LinearProgrammingProblemStandard.objective_dual"><code class="name flex">
<span>def <span class="ident">objective_dual</span></span>(<span>self, y: np.ndarray) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>双対問題の目的関数値の出力</p></div>
</dd>
<dt id="src.problem.problem.LinearProgrammingProblemStandard.objective_main"><code class="name flex">
<span>def <span class="ident">objective_main</span></span>(<span>self, x: np.ndarray) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>主問題の目的関数値の出力</p></div>
</dd>
<dt id="src.problem.problem.LinearProgrammingProblemStandard.residual_dual_constraint"><code class="name flex">
<span>def <span class="ident">residual_dual_constraint</span></span>(<span>self, y: np.ndarray, s: np.ndarray) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>双対問題の制約に対する残渣ベクトルの出力</p></div>
</dd>
<dt id="src.problem.problem.LinearProgrammingProblemStandard.residual_main_constraint"><code class="name flex">
<span>def <span class="ident">residual_main_constraint</span></span>(<span>self, x: np.ndarray) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>主問題の制約に対する残渣ベクトルの出力</p></div>
</dd>
</dl>
</dd>
<dt id="src.problem.problem.SettingProblemError"><code class="flex name class">
<span>class <span class="ident">SettingProblemError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>問題を設定する際に例外が起こったら起こすエラー</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SettingProblemError(Exception):
    &#34;&#34;&#34;問題を設定する際に例外が起こったら起こすエラー&#34;&#34;&#34;
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src.problem" href="index.html">src.problem</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.problem.problem.LinearProgrammingProblem" href="#src.problem.problem.LinearProgrammingProblem">LinearProgrammingProblem</a></code></h4>
<ul class="">
<li><code><a title="src.problem.problem.LinearProgrammingProblem.A_E" href="#src.problem.problem.LinearProgrammingProblem.A_E">A_E</a></code></li>
<li><code><a title="src.problem.problem.LinearProgrammingProblem.A_G" href="#src.problem.problem.LinearProgrammingProblem.A_G">A_G</a></code></li>
<li><code><a title="src.problem.problem.LinearProgrammingProblem.A_L" href="#src.problem.problem.LinearProgrammingProblem.A_L">A_L</a></code></li>
<li><code><a title="src.problem.problem.LinearProgrammingProblem.LB" href="#src.problem.problem.LinearProgrammingProblem.LB">LB</a></code></li>
<li><code><a title="src.problem.problem.LinearProgrammingProblem.LB_index" href="#src.problem.problem.LinearProgrammingProblem.LB_index">LB_index</a></code></li>
<li><code><a title="src.problem.problem.LinearProgrammingProblem.UB" href="#src.problem.problem.LinearProgrammingProblem.UB">UB</a></code></li>
<li><code><a title="src.problem.problem.LinearProgrammingProblem.UB_index" href="#src.problem.problem.LinearProgrammingProblem.UB_index">UB_index</a></code></li>
<li><code><a title="src.problem.problem.LinearProgrammingProblem.b_E" href="#src.problem.problem.LinearProgrammingProblem.b_E">b_E</a></code></li>
<li><code><a title="src.problem.problem.LinearProgrammingProblem.b_G" href="#src.problem.problem.LinearProgrammingProblem.b_G">b_G</a></code></li>
<li><code><a title="src.problem.problem.LinearProgrammingProblem.b_L" href="#src.problem.problem.LinearProgrammingProblem.b_L">b_L</a></code></li>
<li><code><a title="src.problem.problem.LinearProgrammingProblem.c" href="#src.problem.problem.LinearProgrammingProblem.c">c</a></code></li>
<li><code><a title="src.problem.problem.LinearProgrammingProblem.convert_standard" href="#src.problem.problem.LinearProgrammingProblem.convert_standard">convert_standard</a></code></li>
<li><code><a title="src.problem.problem.LinearProgrammingProblem.make_standard_A" href="#src.problem.problem.LinearProgrammingProblem.make_standard_A">make_standard_A</a></code></li>
<li><code><a title="src.problem.problem.LinearProgrammingProblem.make_standard_b" href="#src.problem.problem.LinearProgrammingProblem.make_standard_b">make_standard_b</a></code></li>
<li><code><a title="src.problem.problem.LinearProgrammingProblem.make_standard_c" href="#src.problem.problem.LinearProgrammingProblem.make_standard_c">make_standard_c</a></code></li>
<li><code><a title="src.problem.problem.LinearProgrammingProblem.n" href="#src.problem.problem.LinearProgrammingProblem.n">n</a></code></li>
<li><code><a title="src.problem.problem.LinearProgrammingProblem.name" href="#src.problem.problem.LinearProgrammingProblem.name">name</a></code></li>
<li><code><a title="src.problem.problem.LinearProgrammingProblem.reverse_non_lower_bound" href="#src.problem.problem.LinearProgrammingProblem.reverse_non_lower_bound">reverse_non_lower_bound</a></code></li>
<li><code><a title="src.problem.problem.LinearProgrammingProblem.separate_free_variable" href="#src.problem.problem.LinearProgrammingProblem.separate_free_variable">separate_free_variable</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="src.problem.problem.LinearProgrammingProblemStandard" href="#src.problem.problem.LinearProgrammingProblemStandard">LinearProgrammingProblemStandard</a></code></h4>
<ul class="">
<li><code><a title="src.problem.problem.LinearProgrammingProblemStandard.A" href="#src.problem.problem.LinearProgrammingProblemStandard.A">A</a></code></li>
<li><code><a title="src.problem.problem.LinearProgrammingProblemStandard.b" href="#src.problem.problem.LinearProgrammingProblemStandard.b">b</a></code></li>
<li><code><a title="src.problem.problem.LinearProgrammingProblemStandard.c" href="#src.problem.problem.LinearProgrammingProblemStandard.c">c</a></code></li>
<li><code><a title="src.problem.problem.LinearProgrammingProblemStandard.condition_number_A" href="#src.problem.problem.LinearProgrammingProblemStandard.condition_number_A">condition_number_A</a></code></li>
<li><code><a title="src.problem.problem.LinearProgrammingProblemStandard.create_A_LU_factorized" href="#src.problem.problem.LinearProgrammingProblemStandard.create_A_LU_factorized">create_A_LU_factorized</a></code></li>
<li><code><a title="src.problem.problem.LinearProgrammingProblemStandard.is_full_row_rank" href="#src.problem.problem.LinearProgrammingProblemStandard.is_full_row_rank">is_full_row_rank</a></code></li>
<li><code><a title="src.problem.problem.LinearProgrammingProblemStandard.m" href="#src.problem.problem.LinearProgrammingProblemStandard.m">m</a></code></li>
<li><code><a title="src.problem.problem.LinearProgrammingProblemStandard.max_abs_A" href="#src.problem.problem.LinearProgrammingProblemStandard.max_abs_A">max_abs_A</a></code></li>
<li><code><a title="src.problem.problem.LinearProgrammingProblemStandard.max_sqrt_eigen_value_AAT" href="#src.problem.problem.LinearProgrammingProblemStandard.max_sqrt_eigen_value_AAT">max_sqrt_eigen_value_AAT</a></code></li>
<li><code><a title="src.problem.problem.LinearProgrammingProblemStandard.min_abs_A_nonzero" href="#src.problem.problem.LinearProgrammingProblemStandard.min_abs_A_nonzero">min_abs_A_nonzero</a></code></li>
<li><code><a title="src.problem.problem.LinearProgrammingProblemStandard.min_sqrt_eigen_value_AAT" href="#src.problem.problem.LinearProgrammingProblemStandard.min_sqrt_eigen_value_AAT">min_sqrt_eigen_value_AAT</a></code></li>
<li><code><a title="src.problem.problem.LinearProgrammingProblemStandard.n" href="#src.problem.problem.LinearProgrammingProblemStandard.n">n</a></code></li>
<li><code><a title="src.problem.problem.LinearProgrammingProblemStandard.name" href="#src.problem.problem.LinearProgrammingProblemStandard.name">name</a></code></li>
<li><code><a title="src.problem.problem.LinearProgrammingProblemStandard.objective_dual" href="#src.problem.problem.LinearProgrammingProblemStandard.objective_dual">objective_dual</a></code></li>
<li><code><a title="src.problem.problem.LinearProgrammingProblemStandard.objective_main" href="#src.problem.problem.LinearProgrammingProblemStandard.objective_main">objective_main</a></code></li>
<li><code><a title="src.problem.problem.LinearProgrammingProblemStandard.residual_dual_constraint" href="#src.problem.problem.LinearProgrammingProblemStandard.residual_dual_constraint">residual_dual_constraint</a></code></li>
<li><code><a title="src.problem.problem.LinearProgrammingProblemStandard.residual_main_constraint" href="#src.problem.problem.LinearProgrammingProblemStandard.residual_main_constraint">residual_main_constraint</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="src.problem.problem.SettingProblemError" href="#src.problem.problem.SettingProblemError">SettingProblemError</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
