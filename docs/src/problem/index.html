<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>src.problem API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.problem</code></h1>
</header>
<section id="section-intro">
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="src.problem.preprocessor" href="preprocessor.html">src.problem.preprocessor</a></code></dt>
<dd>
<div class="desc"><p>LPに関する前処理を行う module</p></div>
</dd>
<dt><code class="name"><a title="src.problem.problem" href="problem.html">src.problem.problem</a></code></dt>
<dd>
<div class="desc"><p>最適化問題に関する module</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.problem.LPPreprocessor"><code class="flex name class">
<span>class <span class="ident">LPPreprocessor</span></span>
</code></dt>
<dd>
<div class="desc"><p>LPに関する前処理クラス</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LPPreprocessor:
    &#34;&#34;&#34;LPに関する前処理クラス&#34;&#34;&#34;

    def _remove_rows_and_columns(
        self,
        A: np.ndarray,
        b: np.ndarray = None,
        c: np.ndarray = None,
        rows_remove: set[int] = set(),
        columns_remove: set[int] = set(),
    ) -&gt; tuple[np.ndarray, np.ndarray, np.ndarray]:
        &#34;&#34;&#34;削除する行, 列を指定して, A, b, c から削除する

        Args:
            b: 制約の右辺. 削除する必要がなければ入力しない
            c: 目的関数の係数. 削除する必要がなければ入力しない
            rows_remove: 削除行. 入力されなければ空集合
            columns_remove: 削除列. 入力されなければ空集合
        &#34;&#34;&#34;
        # 残す行, 列を指定
        rows_out = [i for i in range(A.shape[0]) if i not in rows_remove]
        columns_out = [i for i in range(A.shape[1]) if i not in columns_remove]

        # 行が削除された結果
        A_out = A[np.ix_(rows_out, columns_out)]
        if b is not None:
            b_out = b[rows_out]
        else:
            b_out = None
        if c is not None:
            c_out = c[columns_out]
        else:
            c_out = None

        return A_out, b_out, c_out

    def remove_empty_row(self, A: np.ndarray, b: np.ndarray) -&gt; tuple[np.ndarray, np.ndarray]:
        &#34;&#34;&#34;空行で制約が存在しないAの行は削除する

        もしAの係数がないのにbが0以外の場合, どうやってもその制約は満たせないのでエラー
        &#34;&#34;&#34;
        rows_remove = set()
        # A が空行になっているindexに対して処理
        for i in np.where(np.all(A == 0, axis=1))[0]:
            # もしAが空行なのにbが0でなければ実行不可能
            if b[i] != 0:
                raise ProblemInfeasibleError
            rows_remove.add(i)

        A_out, b_out, _ = self._remove_rows_and_columns(A, b=b, rows_remove=rows_remove)
        return A_out, b_out

    def remove_duplicated_row(self, A: np.ndarray, b: np.ndarray) -&gt; tuple[np.ndarray, np.ndarray]:
        &#34;&#34;&#34;重複のある制約を削除

        A_i = k*A_j の時, b_i = k*b_j ならば, jの制約はなくても同じなので削除してよい
        b_i != k*b_j ならば実行不可能になる
        &#34;&#34;&#34;
        m = A.shape[0]

        def scalar_times_vector(vec_a: np.ndarray, vec_b: np.ndarray) -&gt; Optional[float]:
            &#34;&#34;&#34;vec_b が vec_a の定数倍であるならばその値を, そうでなければ None を出力&#34;&#34;&#34;
            # 0の位置が正しくなければ定数倍ではない
            idx_not_zero_a = np.where(vec_a != 0)[0]
            idx_not_zero_b = np.where(vec_b != 0)[0]
            if len(idx_not_zero_a) != len(idx_not_zero_b):
                return None
            if (idx_not_zero_a != idx_not_zero_b).any():
                return None

            # ベクトル全体で割り算を行い, すべて同じ値でなければ定数倍ではない
            scalar_vec = vec_a[idx_not_zero_a] / vec_b[idx_not_zero_b]
            output = scalar_vec[0]
            if np.all(scalar_vec != output):
                return None
            return output

        # 削除する行を保持
        rows_remove = set()
        for i in tqdm(range(m - 1)):
            # すでに削除対象になっている場合省略する
            if i in rows_remove:
                continue
            for j in range(i + 1, m):
                # すでに削除対象になっている場合省略する
                if j in rows_remove:
                    continue
                # 対象とする行が定数倍になっているか確認
                k = scalar_times_vector(A[j, :], A[i, :])
                if k is None:
                    continue
                # 対象とする行が定数倍の場合, bの値も同じ定数倍になっていなければ実行不可能
                if b[j] != b[i] * k:
                    raise ProblemInfeasibleError
                # 削除対象として追加し次の添え字へ
                rows_remove.add(j)

        # 削除対象の行を省いて出力
        A_out, b_out, _ = self._remove_rows_and_columns(A, b=b, rows_remove=rows_remove)
        return A_out, b_out

    def remove_empty_column(self, A: np.ndarray, c: np.ndarray) -&gt; tuple[np.ndarray, np.ndarray]:
        &#34;&#34;&#34;空列で制約が存在しない変数は自由な値を取れるので, 削除する

        自由な値がとれる場合, cが正ならば0が最適値
        cが負ならばいくらでも小さくできてしまうので発散
        &#34;&#34;&#34;
        columns_remove = set()
        # Aが空列になっている index に対してのみ処理
        for i in np.where(np.all(A == 0, axis=0))[0]:
            # もしAが空列なのにcが負であれば unbounded
            if c[i] &lt; 0:
                raise ProblemUnboundedError
            columns_remove.add(i)

        A_out, _, c_out = self._remove_rows_and_columns(A, c=c, columns_remove=columns_remove)
        return A_out, c_out

    def remove_duplicated_column(self, A: np.ndarray, c: np.ndarray) -&gt; tuple[np.ndarray, np.ndarray]:
        &#34;&#34;&#34;重複する列を削除する

        行の場合と異なり, 全く同じ列でなければ削除をしない
        &#34;&#34;&#34;
        n = A.shape[0]

        # 削除する列を保持
        columns_remove = set()
        for i in range(n - 1):
            # すでに削除対象になっている場合省略する
            if i in columns_remove:
                continue
            for j in range(i + 1, n):
                # すでに削除対象になっている場合省略する
                if j in columns_remove:
                    continue
                if np.all(A[:, i] == A[:, j]):
                    columns_remove.add(j)

        # 削除対象の列を省いて出力
        A_out, _, c_out = self._remove_rows_and_columns(A, c=c, columns_remove=columns_remove)
        return A_out, c_out

    def rows_only_one_nonzero(self, A: np.ndarray) -&gt; list[int]:
        &#34;&#34;&#34;Aの行のうち1つしか0以外の係数が存在しない行のインデックス取得

        A が1行m列の制約になった場合エラーとなるので, その時は axis を変更する
        &#34;&#34;&#34;
        if A.shape[1] == 1:
            output = np.where(np.count_nonzero(A, axis=0) == 1)
        else:
            output = np.where(np.count_nonzero(A, axis=1) == 1)
        return output[0]

    def only_one_nonzero_elements_and_columns(
        self, A: np.ndarray, row_indexs_only_one_nonzero: list[int]
    ) -&gt; tuple[np.ndarray, list[int]]:
        &#34;&#34;&#34;1つしか係数がない行の係数のベクトル形式と, 列のインデックスを取得&#34;&#34;&#34;
        A_only_one_nonzero = A[row_indexs_only_one_nonzero, :]
        indexes_tmp = np.nonzero(A_only_one_nonzero)
        return A_only_one_nonzero[indexes_tmp], indexes_tmp[1]

    def remove_row_singleton(
        self, A: np.ndarray, b: np.ndarray, c: np.ndarray
    ) -&gt; tuple[np.ndarray, np.ndarray, np.ndarray]:
        &#34;&#34;&#34;1つしか係数がかかっていない行は1つの値に定めることで次元数削除&#34;&#34;&#34;
        # 1つしか係数がない行の特定
        rows_remove = self.rows_only_one_nonzero(A)

        # 1つしか係数がない行がないならばそのまま出力
        if len(rows_remove) == 0:
            return A, b, c

        # 1つしか係数がない行の係数とその列を取得
        elements, columns_remove = self.only_one_nonzero_elements_and_columns(A, rows_remove)

        # 変数の確定. もし負の値になってしまったら実行不可能
        x = b[rows_remove] / elements
        if len(np.where(x &lt; 0)[0]):
            raise ProblemInfeasibleError

        # 行が削除された結果
        A_new, _, c_new = self._remove_rows_and_columns(A, c=c, rows_remove=rows_remove, columns_remove=columns_remove)
        # bのみ値が変わるため, 別で計算する
        rows_output = [i for i in range(A.shape[0]) if i not in rows_remove]
        b_new = b[rows_output] - A[np.ix_(rows_output, columns_remove)].dot(x)

        # 行を削除した結果, 再び要素が1つだけの行ができるかもしれないので再度実行
        A_out, b_out, c_out = self.remove_row_singleton(A_new, b_new, c_new)
        return A_out, b_out, c_out

    def find_zero_columns_in_A(self, A: np.ndarray, column: int) -&gt; list[int]:
        &#34;&#34;&#34;Aのj列に対して足して0になる列のリストを取得

        j-1列目までは確認していると考えて, j+1列目以降と比較する

        Args:
            A: 制約の係数行列
            column: Aのどの列と他の列が同じか参照するか（j列目）
        &#34;&#34;&#34;
        A_j_minus_A = A[:, column].reshape(A.shape[0], 1) + A[:, (column + 1) :]
        index_0 = np.where(np.all(A_j_minus_A == 0, axis=0))[0]
        return (index_0 + column + 1).tolist()

    def remove_free_variables(
        self, A: np.ndarray, b: np.ndarray, c: np.ndarray
    ) -&gt; tuple[np.ndarray, np.ndarray, np.ndarray]:
        &#34;&#34;&#34;Aの列が足して0になり, かつcの対応する添え字も同様であれば,
        2つの変数の差は自由変数として扱うことができるので,
        値を固定して次元を削減する
        &#34;&#34;&#34;
        n = A.shape[1]
        for i in range(n - 1):
            logger.debug(f&#34;Reference column: {i}&#34;)
            # 足して0になるAの列を見つける
            lst_columns = self.find_zero_columns_in_A(A, i)
            if not lst_columns:
                continue
            # 削除対象となるのは, for文で参照している列と足して0になるAの列の1つ
            columns_remove = [i, lst_columns[0]]
            cols_calc = [j for j in range(n) if j not in columns_remove]
            # 参照している列において係数が0以外である行を見つける
            lst_rows_nonzero_column = np.where(A[:, i] != 0)[0].tolist()
            # 係数が0しかない場合, 自由変数の削除としては扱わない
            if not lst_rows_nonzero_column:
                continue
            # 係数が0以外である最初の行のインデックスとその係数を取得
            row_remove = lst_rows_nonzero_column[0]
            A_alpha_i = A[row_remove, i]
            # 係数が0以外である各行に対して, 自由変数の係数と割り算
            rows_calc = lst_rows_nonzero_column[1:]
            # 対応する各要素に対して更新
            c = c - c[i] * A[row_remove, :] / A_alpha_i
            b = b - A[:, i] * b[row_remove] / A_alpha_i
            # 下記のAの行列計算は以下のfor文を行っている
            # for k in range(n):
            #     if k in columns_remove:
            #         continue
            #     tmp = A[rows_calc, i] / A_alpha_i * A[row_remove, k]
            #     A[rows_calc, k] = A[rows_calc, k] - tmp
            comb = np.ix_(rows_calc, cols_calc)
            logger.debug(f&#34;Remove row: {row_remove}&#34;)
            logger.debug(f&#34;Remove columns: {columns_remove}&#34;)
            A_beta_i = A[rows_calc, i].reshape(len(rows_calc), 1)
            A_alpha_k = A[row_remove, cols_calc].reshape(1, len(cols_calc))
            A_beta_i_A_alpha_k = A_beta_i.dot(A_alpha_k)
            A[comb] = A[comb] - A_beta_i_A_alpha_k / A_alpha_i
            A_row_removed = np.delete(A, row_remove, axis=0)
            A_new = np.delete(A_row_removed, columns_remove, axis=1)
            b_new = np.delete(b, row_remove, axis=0)
            c_new = np.delete(c, columns_remove, axis=0)
            # 自由変数を削除することで新たな自由変数が出現するかもしれないので再帰
            return self.remove_free_variables(A_new, b_new, c_new)
        # 足して0になる列の組がなければそのまま返す
        else:
            return A, b, c

    def fix_variables_by_single_row(
        self, A: np.ndarray, b: np.ndarray, c: np.ndarray
    ) -&gt; tuple[np.ndarray, np.ndarray, np.ndarray]:
        &#34;&#34;&#34;bが負の時に制約が正の係数しか持たない, もしくはbが正の時に制約が負の係数しか
        もたない場合実行不可能. bが0の時に制約が正 or 負どちらかの係数しか持たない場合,
        解はすべて0として制約と変数を削除する
        &#34;&#34;&#34;
        # 実行不可能性の確認
        rows_b_negative = np.where(b &lt; 0)[0]
        if np.any(np.all(A[rows_b_negative, :] &gt;= 0, axis=1)):
            raise ProblemInfeasibleError
        rows_b_positive = np.where(b &gt; 0)[0]
        if np.any(np.all(A[rows_b_positive, :] &lt;= 0, axis=1)):
            raise ProblemInfeasibleError

        # 制約, 変数の削除
        rows_remove = set()
        columns_remove = set()
        rows_b_zero = np.where(b == 0)[0]
        for row in rows_b_zero:
            row_A = A[row, :]
            columns_A_nonzero = np.where(row_A != 0)[0]
            # 係数が正 or 負のどちらかしか持たない場合, 解はすべて0とする
            if np.all(row_A &gt;= 0) or np.all(row_A &lt;= 0):
                rows_remove.add(row)
                columns_remove = columns_remove | set(columns_A_nonzero)

        # もし何も削除されなかった場合, そのまま入力を返す
        if not (rows_remove or columns_remove):
            return A, b, c

        # 残す制約, 変数を抽出
        A_new, b_new, c_new = self._remove_rows_and_columns(
            A, b=b, c=c, rows_remove=rows_remove, columns_remove=columns_remove
        )

        # 削除した結果, 再び同じ条件の行列ができるかもしれないので再度実行
        A_out, b_out, c_out = self.fix_variables_by_single_row(A_new, b_new, c_new)
        return A_out, b_out, c_out

    def fix_variables_by_multiple_rows(
        self, A: np.ndarray, b: np.ndarray, c: np.ndarray
    ) -&gt; tuple[np.ndarray, np.ndarray, np.ndarray]:
        &#34;&#34;&#34;bの値が同じ制約において, 制約の係数同士を引いた場合に負か正の値しかない場合,
        その値は0にならなければ実行不可能
        bの値が足して0になる場合も同様. その場合制約の係数同士を足した場合になる
        &#34;&#34;&#34;
        # 削除する行, 列の保持
        rows_remove = set()
        columns_remove = set()

        for i, b_i in tqdm(enumerate(b)):
            if i in rows_remove:
                continue

            # b が同じだった場合
            b_i_minus_b = b_i - b[i + 1 :]
            rows_zero = np.where(b_i_minus_b == 0)[0] + (i + 1)
            for j in set(rows_zero) - rows_remove:
                A_i_minus_A_j = A[i, :] - A[j, :]
                if max(A_i_minus_A_j) &lt;= 0 or min(A_i_minus_A_j) &gt;= 0:
                    rows_remove.add(j)
                    columns_non_zero = np.where(A_i_minus_A_j != 0)[0]
                    columns_remove = columns_remove | set(columns_non_zero)

            # b が足して0だった場合
            b_i_plus_b = b_i + b[i + 1 :]
            rows_zero = np.where(b_i_plus_b == 0)[0] + (i + 1)
            for j in set(rows_zero) - rows_remove:
                A_i_plus_A_j = A[i, :] + A[j, :]
                if max(A_i_plus_A_j) &lt;= 0 or min(A_i_plus_A_j) &gt;= 0:
                    rows_remove.add(j)
                    columns_non_zero = np.where(A_i_plus_A_j != 0)[0]
                    columns_remove = columns_remove | set(columns_non_zero)

        # 残す制約, 変数を抽出
        A_new, b_new, c_new = self._remove_rows_and_columns(
            A, b=b, c=c, rows_remove=rows_remove, columns_remove=columns_remove
        )

        return A_new, b_new, c_new

    def fix_positive_variable_by_signs(
        self, A: np.ndarray, b: np.ndarray, c: np.ndarray, recursive_num: int = 0
    ) -&gt; tuple[np.ndarray, np.ndarray, np.ndarray]:
        &#34;&#34;&#34;ある行がbと同じ符号の係数が1つしかなく, それ以外は反対の符号, もしくは0の場合
        bと同じ符号の変数は他の変数との和で固定する

        Args:
            recursive_num: 再帰した回数. 再帰しすぎるとメモリエラーになるため, 50回を限度とする
        &#34;&#34;&#34;
        if recursive_num &gt; 50:
            return A, b, c

        # bが0以外の場合について, 条件に合致するAの行を取得
        for row in np.where(b != 0)[0]:
            # Aの要素がbの符号と同じ添え字を取得
            indexs_A_alpha_with_b = np.where(A[row, :] * b[row] / abs(b[row]) &gt; 0)[0]
            # 要素が1つのみの場合, indexを取得し走査終了
            if len(indexs_A_alpha_with_b) == 1:
                remove_row = row
                remove_col = indexs_A_alpha_with_b[0]
                break
        # 該当する条件の行がなかった場合は入力された行列を出力へ
        else:
            return A, b, c

        # 各行, 列に対して値を更新
        A_alpha = A[remove_row, :]
        A_alpha_i = A_alpha[remove_col]
        A_beta_i = A[:, remove_col].reshape(A.shape[0], 1)
        A_new, b_new, c_new = self._remove_rows_and_columns(
            A - A_beta_i * A_alpha.reshape(1, A.shape[1]) / A_alpha_i,
            b=b - A[:, remove_col] * b[remove_row] / A_alpha_i,
            c=c - c[remove_col] * A_alpha / A_alpha_i,
            rows_remove={remove_row},
            columns_remove={remove_col},
        )
        # 不要なオブジェクトを削除して再帰
        del A_alpha, A_beta_i, A, b, c
        num = recursive_num + 1
        return self.fix_positive_variable_by_signs(A_new, b_new, c_new, num)

    def fix_singleton_by_two_rows(
        self, A: np.ndarray, b: np.ndarray, c: np.ndarray
    ) -&gt; tuple[np.ndarray, np.ndarray, np.ndarray]:
        &#34;&#34;&#34;2つの行の差が1列しか非0要素を持たない場合,
        1つの変数を固定することができるので固定することで変数を削除する

        もし固定した結果が負の値になる場合は実行不可能
        &#34;&#34;&#34;
        for i in range(A.shape[0] - 1):
            A_i_minus_A = A[i, :] - A[(i + 1) :, :]
            # 各行で非0要素になった数を集計
            counts_nonzero_by_row = np.count_nonzero(A_i_minus_A != 0, axis=1)
            # もしなければ次の行へ
            if 1 not in counts_nonzero_by_row:
                continue
            # あれば, その行が何行目か取得して, 変数を固定する
            index = counts_nonzero_by_row.tolist().index(1)
            remove_row = index + i + 1
            remove_column = np.where(A_i_minus_A[index, :] != 0)[0]
            x_denominator = A[i, remove_column] - A[remove_row, remove_column]
            x = (b[i] - b[remove_row]) / x_denominator
            # 固定した値が負であれば実行不可能
            if x &lt; 0:
                raise ProblemInfeasibleError
            # 値の更新
            b_updated = b - A[:, remove_column].flatten() * x
            A_new, b_new, c_new = self._remove_rows_and_columns(
                A, b=b_updated, c=c, rows_remove=[remove_row], columns_remove=[remove_column]
            )
            # 削除した結果, 再び同じ条件の行列ができるかもしれないので再度実行
            return self.fix_singleton_by_two_rows(A_new, b_new, c_new)
        # 該当する条件の行がなかった場合はそのまま返す
        else:
            return A, b, c

    def run(self, problem: LPS) -&gt; LPS:
        &#34;&#34;&#34;前処理を実行し, 新しいLPのインスタンスを作成する

        一度実行した後にA, b, cが変形していれば, 再び0の行が出るなどして前処理が必要になるかもしれない
        そのため, 繰り返し出力する

        Returns:
            LPS: 前処理後の線形計画問題
        &#34;&#34;&#34;
        logger.info(&#34;Start preprocessing.&#34;)
        A = problem.A.copy()
        b = problem.b.copy()
        c = problem.c.copy()

        logger.info(&#34;1. Start removing empty rows.&#34;)
        A, b = self.remove_empty_row(A, b)
        # logger.info(&#34;2. Start removing duplicated rows.&#34;)
        # A, b = self.remove_duplicated_row(A, b)
        logger.info(&#34;3. Start removing empty columns.&#34;)
        A, c = self.remove_empty_column(A, c)
        # logger.info(&#34;4. Start removing duplicated columns.&#34;)
        # A, c = self.remove_duplicated_column(A, c)
        logger.info(&#34;5. Start removing row singletons.&#34;)
        A, b, c = self.remove_row_singleton(A, b, c)
        # logger.info(&#34;6. Start removing free variables.&#34;)
        # A, b, c = self.remove_free_variables(A, b, c)
        logger.info(&#34;7. Start fixing variables by single row.&#34;)
        A, b, c = self.fix_variables_by_single_row(A, b, c)
        # logger.info(&#34;8. Start fixing variables by multiple rows.&#34;)
        # A, b, c = self.fix_variables_by_multiple_rows(A, b, c)
        logger.info(&#34;9. Start fixing positive variable by sings.&#34;)
        A, b, c = self.fix_positive_variable_by_signs(A, b, c)
        # logger.info(&#34;10. Start fixing singleton by two rows.&#34;)
        # A, b, c = self.fix_singleton_by_two_rows(A, b, c)

        # A, b, c について変更されているか確認し, もしされていなければ出力
        logger.info(&#34;Checking changing...&#34;)
        # まずは次元の確認から. 一致していることがわかった後に要素の確認をしないとサイズ違いでエラーとなる
        if A.shape == problem.A.shape and b.shape == problem.b.shape and c.shape == problem.c.shape:
            if np.all(A == problem.A) and np.all(b == problem.b) and np.all(c == problem.c):
                logger.info(&#34;End preprocessing.&#34;)
                if not problem.is_full_row_rank():
                    logger.warning(&#34;This problem is not full row rank!&#34;)
                return problem
        # されていればもう一度実行
        logger.info(&#34;Restart Preprocessing for changing coefficients.&#34;)
        # 不要なオブジェクトはメモリを圧迫するので削除
        name = problem.name
        del problem
        return self.run(LPS(A, b, c, name))</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="src.problem.LPPreprocessor.find_zero_columns_in_A"><code class="name flex">
<span>def <span class="ident">find_zero_columns_in_A</span></span>(<span>self, A: numpy.ndarray, column: int) ‑> list[int]</span>
</code></dt>
<dd>
<div class="desc"><p>Aのj列に対して足して0になる列のリストを取得</p>
<p>j-1列目までは確認していると考えて, j+1列目以降と比較する</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>A</code></strong></dt>
<dd>制約の係数行列</dd>
<dt><strong><code>column</code></strong></dt>
<dd>Aのどの列と他の列が同じか参照するか（j列目）</dd>
</dl></div>
</dd>
<dt id="src.problem.LPPreprocessor.fix_positive_variable_by_signs"><code class="name flex">
<span>def <span class="ident">fix_positive_variable_by_signs</span></span>(<span>self, A: numpy.ndarray, b: numpy.ndarray, c: numpy.ndarray, recursive_num: int = 0) ‑> tuple[numpy.ndarray, numpy.ndarray, numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>ある行がbと同じ符号の係数が1つしかなく, それ以外は反対の符号, もしくは0の場合
bと同じ符号の変数は他の変数との和で固定する</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>recursive_num</code></strong></dt>
<dd>再帰した回数. 再帰しすぎるとメモリエラーになるため, 50回を限度とする</dd>
</dl></div>
</dd>
<dt id="src.problem.LPPreprocessor.fix_singleton_by_two_rows"><code class="name flex">
<span>def <span class="ident">fix_singleton_by_two_rows</span></span>(<span>self, A: numpy.ndarray, b: numpy.ndarray, c: numpy.ndarray) ‑> tuple[numpy.ndarray, numpy.ndarray, numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>2つの行の差が1列しか非0要素を持たない場合,
1つの変数を固定することができるので固定することで変数を削除する</p>
<p>もし固定した結果が負の値になる場合は実行不可能</p></div>
</dd>
<dt id="src.problem.LPPreprocessor.fix_variables_by_multiple_rows"><code class="name flex">
<span>def <span class="ident">fix_variables_by_multiple_rows</span></span>(<span>self, A: numpy.ndarray, b: numpy.ndarray, c: numpy.ndarray) ‑> tuple[numpy.ndarray, numpy.ndarray, numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>bの値が同じ制約において, 制約の係数同士を引いた場合に負か正の値しかない場合,
その値は0にならなければ実行不可能
bの値が足して0になる場合も同様. その場合制約の係数同士を足した場合になる</p></div>
</dd>
<dt id="src.problem.LPPreprocessor.fix_variables_by_single_row"><code class="name flex">
<span>def <span class="ident">fix_variables_by_single_row</span></span>(<span>self, A: numpy.ndarray, b: numpy.ndarray, c: numpy.ndarray) ‑> tuple[numpy.ndarray, numpy.ndarray, numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>bが負の時に制約が正の係数しか持たない, もしくはbが正の時に制約が負の係数しか
もたない場合実行不可能. bが0の時に制約が正 or 負どちらかの係数しか持たない場合,
解はすべて0として制約と変数を削除する</p></div>
</dd>
<dt id="src.problem.LPPreprocessor.only_one_nonzero_elements_and_columns"><code class="name flex">
<span>def <span class="ident">only_one_nonzero_elements_and_columns</span></span>(<span>self, A: numpy.ndarray, row_indexs_only_one_nonzero: list[int]) ‑> tuple[numpy.ndarray, list[int]]</span>
</code></dt>
<dd>
<div class="desc"><p>1つしか係数がない行の係数のベクトル形式と, 列のインデックスを取得</p></div>
</dd>
<dt id="src.problem.LPPreprocessor.remove_duplicated_column"><code class="name flex">
<span>def <span class="ident">remove_duplicated_column</span></span>(<span>self, A: numpy.ndarray, c: numpy.ndarray) ‑> tuple[numpy.ndarray, numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>重複する列を削除する</p>
<p>行の場合と異なり, 全く同じ列でなければ削除をしない</p></div>
</dd>
<dt id="src.problem.LPPreprocessor.remove_duplicated_row"><code class="name flex">
<span>def <span class="ident">remove_duplicated_row</span></span>(<span>self, A: numpy.ndarray, b: numpy.ndarray) ‑> tuple[numpy.ndarray, numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>重複のある制約を削除</p>
<p>A_i = k<em>A_j の時, b_i = k</em>b_j ならば, jの制約はなくても同じなので削除してよい
b_i != k*b_j ならば実行不可能になる</p></div>
</dd>
<dt id="src.problem.LPPreprocessor.remove_empty_column"><code class="name flex">
<span>def <span class="ident">remove_empty_column</span></span>(<span>self, A: numpy.ndarray, c: numpy.ndarray) ‑> tuple[numpy.ndarray, numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>空列で制約が存在しない変数は自由な値を取れるので, 削除する</p>
<p>自由な値がとれる場合, cが正ならば0が最適値
cが負ならばいくらでも小さくできてしまうので発散</p></div>
</dd>
<dt id="src.problem.LPPreprocessor.remove_empty_row"><code class="name flex">
<span>def <span class="ident">remove_empty_row</span></span>(<span>self, A: numpy.ndarray, b: numpy.ndarray) ‑> tuple[numpy.ndarray, numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>空行で制約が存在しないAの行は削除する</p>
<p>もしAの係数がないのにbが0以外の場合, どうやってもその制約は満たせないのでエラー</p></div>
</dd>
<dt id="src.problem.LPPreprocessor.remove_free_variables"><code class="name flex">
<span>def <span class="ident">remove_free_variables</span></span>(<span>self, A: numpy.ndarray, b: numpy.ndarray, c: numpy.ndarray) ‑> tuple[numpy.ndarray, numpy.ndarray, numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>Aの列が足して0になり, かつcの対応する添え字も同様であれば,
2つの変数の差は自由変数として扱うことができるので,
値を固定して次元を削減する</p></div>
</dd>
<dt id="src.problem.LPPreprocessor.remove_row_singleton"><code class="name flex">
<span>def <span class="ident">remove_row_singleton</span></span>(<span>self, A: numpy.ndarray, b: numpy.ndarray, c: numpy.ndarray) ‑> tuple[numpy.ndarray, numpy.ndarray, numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>1つしか係数がかかっていない行は1つの値に定めることで次元数削除</p></div>
</dd>
<dt id="src.problem.LPPreprocessor.rows_only_one_nonzero"><code class="name flex">
<span>def <span class="ident">rows_only_one_nonzero</span></span>(<span>self, A: numpy.ndarray) ‑> list[int]</span>
</code></dt>
<dd>
<div class="desc"><p>Aの行のうち1つしか0以外の係数が存在しない行のインデックス取得</p>
<p>A が1行m列の制約になった場合エラーとなるので, その時は axis を変更する</p></div>
</dd>
<dt id="src.problem.LPPreprocessor.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, problem: <a title="src.problem.problem.LinearProgrammingProblemStandard" href="problem.html#src.problem.problem.LinearProgrammingProblemStandard">LinearProgrammingProblemStandard</a>) ‑> <a title="src.problem.problem.LinearProgrammingProblemStandard" href="problem.html#src.problem.problem.LinearProgrammingProblemStandard">LinearProgrammingProblemStandard</a></span>
</code></dt>
<dd>
<div class="desc"><p>前処理を実行し, 新しいLPのインスタンスを作成する</p>
<p>一度実行した後にA, b, cが変形していれば, 再び0の行が出るなどして前処理が必要になるかもしれない
そのため, 繰り返し出力する</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>LPS</code></dt>
<dd>前処理後の線形計画問題</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="src.problem.LinearProgrammingProblem"><code class="flex name class">
<span>class <span class="ident">LinearProgrammingProblem</span></span>
<span>(</span><span>A_E: np.ndarray, b_E: np.ndarray, A_G: np.ndarray, b_G: np.ndarray, A_L: np.ndarray, b_L: np.ndarray, LB_index: list[int], LB: np.ndarray, UB_index: list[int], UB: np.ndarray, c: np.ndarray, name: str = '')</span>
</code></dt>
<dd>
<div class="desc"><p>線形計画問題に関するクラス</p>
<p>以下の問題について定数を格納する
min c.T @ x
s.t.
A_E @ x = b_E
A_G @ x &gt;= b_G
A_L @ x &lt;= b_L
x[LB_index] &gt;= LB
x[UB_index] &lt;= UB</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>LB_index</code></strong></dt>
<dd>変数の下限が存在する場合のその添え字リスト.
変数の下限が存在しない場合もあるため index を指定する必要がある</dd>
<dt><strong><code>LB</code></strong></dt>
<dd>変数の下限. LO_index 通りにソートされている</dd>
<dt><strong><code>UB_index</code></strong></dt>
<dd>変数の上限が存在する場合のその添え字リスト.
変数の上限が存在しない場合もあるため index を指定する必要がある</dd>
<dt><strong><code>UB</code></strong></dt>
<dd>変数の上限. UP_index 通りにソートされている</dd>
<dt><strong><code>name</code></strong></dt>
<dd>問題名. デフォルトは空白</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclasses.dataclass
class LinearProgrammingProblem:
    &#34;&#34;&#34;線形計画問題に関するクラス

    以下の問題について定数を格納する
    min c.T @ x
    s.t.
        A_E @ x = b_E
        A_G @ x &gt;= b_G
        A_L @ x &lt;= b_L
        x[LB_index] &gt;= LB
        x[UB_index] &lt;= UB

    Args:
        LB_index: 変数の下限が存在する場合のその添え字リスト.
            変数の下限が存在しない場合もあるため index を指定する必要がある
        LB: 変数の下限. LO_index 通りにソートされている
        UB_index: 変数の上限が存在する場合のその添え字リスト.
            変数の上限が存在しない場合もあるため index を指定する必要がある
        UB: 変数の上限. UP_index 通りにソートされている
        name: 問題名. デフォルトは空白
    &#34;&#34;&#34;
    A_E: np.ndarray
    b_E: np.ndarray
    A_G: np.ndarray
    b_G: np.ndarray
    A_L: np.ndarray
    b_L: np.ndarray
    LB_index: list[int]
    LB: np.ndarray
    UB_index: list[int]
    UB: np.ndarray
    c: np.ndarray
    name: str = &#34;&#34;

    @property
    def n(self):
        &#34;&#34;&#34;変数の次元数

        A_* が空行列となる場合があるため, c の次元から取得
        &#34;&#34;&#34;
        return self.c.shape[0]

    def __eq__(self, other: object) -&gt; bool:
        &#34;&#34;&#34;要素が `np.array` なので, 標準の __eq__ メソッドだとエラーになる

        TODO:
            * LB, UB でも判定するようにする
        &#34;&#34;&#34;
        is_same_A_E = np.array_equal(self.A_E, other.A_E)
        is_same_b_E = np.array_equal(self.b_E, other.b_E)
        is_same_A_G = np.array_equal(self.A_G, other.A_G)
        is_same_b_G = np.array_equal(self.b_G, other.b_G)
        is_same_A_L = np.array_equal(self.A_L, other.A_L)
        is_same_b_L = np.array_equal(self.b_L, other.b_L)
        is_same_A = is_same_A_E and is_same_A_G and is_same_A_L
        is_same_b = is_same_b_E and is_same_b_G and is_same_b_L
        is_same_c = np.array_equal(self.c, other.c)
        return is_same_A and is_same_b and is_same_c

    # 以下、標準系に修正するための処理
    # データが入っていなくても実行可能なため classmethod
    @classmethod
    def reverse_non_lower_bound(
        cls, lb: np.ndarray, ub: np.ndarray,
        A: np.ndarray, c: np.ndarray
    ) -&gt; tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]:
        &#34;&#34;&#34;変数の下限が存在せず, 上限が存在する場合, 対応する変数の添え字の符号を反転させる

        Args:
            lb: 変数の下限. 下限がない次元は -inf
            ub: 変数の上限. 上限がない次元は inf
            A: A
            c: c

        Returns:
            np.ndarray: 変数の lower bound
            np.ndarray: 変数の upper bound
            np.ndarray: A. のちにどの制約かによって区分けするが, ここでの出力はひとまとめにしたもの
            np.ndarray: c
        &#34;&#34;&#34;
        # 下限が存在せず, 上限が存在する添え字の取得
        id_lb_inf = np.where(lb == -np.inf)[0]
        id_ub_non_inf = np.where(ub != np.inf)[0]
        indexes = list(set(id_lb_inf) &amp; set(id_ub_non_inf))

        # 対象の添え字の符号を反転する
        lb_out = lb.copy()
        ub_out = ub.copy()
        lb_out[indexes], ub_out[indexes] = -ub[indexes], -lb[indexes]
        A_out = A.copy()
        A_out[:, indexes] = -A[:, indexes]
        c_out = c.copy()
        c_out[indexes] = -c[indexes]
        return lb_out, ub_out, A_out, c_out

    @classmethod
    def separate_free_variable(
        cls, lb: np.ndarray, ub: np.ndarray, A: np.ndarray, c: np.ndarray
    ) -&gt; tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]:
        &#34;&#34;&#34;変数に下限も上限もない自由変数の場合, 新しい変数列を作成して正の部分と負の部分に分ける

        正部分に関する変数は同じ場所に残し, 負部分に関する変数は末尾に追加する
        正部分は, 下限を0に変更するのみ
        負部分は, 下限0, 上限inf, -A_{正部分}, c_{正部分} をそれぞれ追加する

        Args:
            lb: 変数の下限. 下限がない次元は -inf
            ub: 変数の上限. 上限がない次元は inf
            A: A
            c: c

        Returns:
            np.ndarray: 変数の lower bound
            np.ndarray: 変数の upper bound
            np.ndarray: A
            np.ndarray: c
        &#34;&#34;&#34;
        # 自由変数の添え字の取得
        id_lb_inf = np.where(lb == -np.inf)[0]
        id_ub_non_inf = np.where(ub == np.inf)[0]
        indexes = list(set(id_lb_inf) &amp; set(id_ub_non_inf))
        # 出力を入力からコピー. このインスタンスに追加する
        lb_out = lb.copy()
        ub_out = ub.copy()
        A_out = A.copy()
        c_out = c.copy()
        # Aに列追加する際に reshape が必要なので, 行数を取っておく
        m = A.shape[0]

        # 各自由変数ごとに追加する
        for id_ in indexes:
            # 正部分の添え字
            lb_out[id_] = 0
            # 負部分の添え字（追加）
            lb_out = np.append(lb_out, 0)
            ub_out = np.append(ub_out, np.inf)
            A_out = np.concatenate([A_out, -A[:, id_].reshape(m, 1)], axis=1)
            c_out = np.append(c_out, -c[id_])
        return lb_out, ub_out, A_out, c_out

    @classmethod
    def make_standard_A(
        cls, A_E: np.ndarray, A_G: np.ndarray, A_L: np.ndarray, ub: np.ndarray
    ) -&gt; np.ndarray:
        &#34;&#34;&#34;等式制約, 不等式制約から標準形式の係数行列を作成する

        Args:
            A_E: 等式制約に関する係数行列
            A_G: 下限制約に関する係数行列
            A_L: 上限制約に関する係数行列
            ub: 変数の上限. 上限が存在しない次元は inf
        &#34;&#34;&#34;
        lst_index_up = np.where(ub != np.inf)[0]

        # 各次元取得
        n = A_E.shape[1]
        m_e = A_E.shape[0]
        m_g = A_G.shape[0]
        m_l = A_L.shape[0]
        m_b = len(lst_index_up)

        # box constraint に関する単位行列を作成
        A_B = np.zeros([m_b, n])
        for i, index_up in enumerate(lst_index_up):
            A_B[i, index_up] = 1

        # 組み合わせて一つの行列に
        output = np.concatenate([
            np.concatenate([A_E, np.zeros([m_e, m_g + m_l + m_b])], 1),
            np.concatenate([A_G, -np.eye(m_g), np.zeros([m_g, m_l + m_b])], 1),
            np.concatenate(
                [A_L, np.zeros([m_l, m_g]), np.eye(m_l), np.zeros([m_l, m_b])],
                1
            ),
            np.concatenate([A_B, np.zeros([m_b, m_g + m_l]), np.eye(m_b)], 1)
        ])
        return output

    @classmethod
    def make_standard_b(
        cls, A_E, A_G, A_L, b_E, b_G, b_L, lb, ub
    ) -&gt; np.ndarray:
        &#34;&#34;&#34;等式制約, 不等式制約から標準形式の right hand side を作成する

        Args:
            A_E: 等式制約に関する係数行列
            A_G: 下限制約に関する係数行列
            A_L: 上限制約に関する係数行列
            b_E: 等式制約に関する右辺
            b_G: 下限制約に関する右辺
            b_L: 上限制約に関する右辺
            lb: 変数の下限値
            ub: 変数の上限値. inf であれば上限を設定する必要がない
        &#34;&#34;&#34;
        lst_index_up = np.where(ub != np.inf)[0]

        b = np.concatenate([
            b_E - A_E @ lb,
            b_G - A_G @ lb,
            b_L - A_L @ lb,
            ub[lst_index_up] - lb[lst_index_up]
        ])
        return b

    @classmethod
    def make_standard_c(
        cls, c: np.ndarray, m_GL: int, ub: np.ndarray
    ) -&gt; np.ndarray:
        &#34;&#34;&#34;不等式制約から標準形式の目的関数係数を作成する

        Args:
            c: c
            m_GL: 上限, 下限不等式制約の数を合わせた数
            ub: 変数の上限. 上限が存在しない次元は inf
        &#34;&#34;&#34;
        m_B = len(np.where(ub != np.inf)[0])
        return np.concatenate([c, np.zeros(m_GL + m_B)])

    def convert_standard(self) -&gt; LinearProgrammingProblemStandard:
        &#34;&#34;&#34;等式制約のみの標準形線形計画問題に修正する&#34;&#34;&#34;
        # 変数の正負, 自由変数において変更があるため A はまとめておく
        A = np.concatenate([self.A_E, self.A_G, self.A_L])

        # 変数の上下限が存在しない箇所は発散させておく
        lb = np.full(self.n, -np.inf)
        lb[self.LB_index] = self.LB
        ub = np.full(self.n, np.inf)
        ub[self.UB_index] = self.UB

        # 変数すべてに下限を設定
        lb_tmp, ub_tmp, A_tmp, c_tmp = self.separate_free_variable(
            *self.reverse_non_lower_bound(lb, ub, A, self.c)
        )
        # 等式制約に統一するため不等式制約を別々にする
        m_e = self.A_E.shape[0]
        m_g = self.A_G.shape[0]
        m_l = self.A_L.shape[0]
        A_E = A_tmp[range(m_e), :]
        A_G = A_tmp[range(m_e, m_e + m_g), :]
        m_gl = m_g + m_l
        A_L = A_tmp[range(m_e + m_g, m_e + m_gl), :]

        # 変形して標準形式の A, b, c 作成
        A_out = self.make_standard_A(A_E, A_G, A_L, ub_tmp)
        b_out = self.make_standard_b(
            A_E, A_G, A_L, self.b_E, self.b_G, self.b_L, lb_tmp, ub_tmp
        )
        c_out = self.make_standard_c(c_tmp, m_gl, ub_tmp)

        return LinearProgrammingProblemStandard(A_out, b_out, c_out, self.name)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="src.problem.LinearProgrammingProblem.A_E"><code class="name">var <span class="ident">A_E</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.problem.LinearProgrammingProblem.A_G"><code class="name">var <span class="ident">A_G</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.problem.LinearProgrammingProblem.A_L"><code class="name">var <span class="ident">A_L</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.problem.LinearProgrammingProblem.LB"><code class="name">var <span class="ident">LB</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.problem.LinearProgrammingProblem.LB_index"><code class="name">var <span class="ident">LB_index</span> : list[int]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.problem.LinearProgrammingProblem.UB"><code class="name">var <span class="ident">UB</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.problem.LinearProgrammingProblem.UB_index"><code class="name">var <span class="ident">UB_index</span> : list[int]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.problem.LinearProgrammingProblem.b_E"><code class="name">var <span class="ident">b_E</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.problem.LinearProgrammingProblem.b_G"><code class="name">var <span class="ident">b_G</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.problem.LinearProgrammingProblem.b_L"><code class="name">var <span class="ident">b_L</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.problem.LinearProgrammingProblem.c"><code class="name">var <span class="ident">c</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.problem.LinearProgrammingProblem.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="src.problem.LinearProgrammingProblem.make_standard_A"><code class="name flex">
<span>def <span class="ident">make_standard_A</span></span>(<span>A_E: np.ndarray, A_G: np.ndarray, A_L: np.ndarray, ub: np.ndarray) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>等式制約, 不等式制約から標準形式の係数行列を作成する</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>A_E</code></strong></dt>
<dd>等式制約に関する係数行列</dd>
<dt><strong><code>A_G</code></strong></dt>
<dd>下限制約に関する係数行列</dd>
<dt><strong><code>A_L</code></strong></dt>
<dd>上限制約に関する係数行列</dd>
<dt><strong><code>ub</code></strong></dt>
<dd>変数の上限. 上限が存在しない次元は inf</dd>
</dl></div>
</dd>
<dt id="src.problem.LinearProgrammingProblem.make_standard_b"><code class="name flex">
<span>def <span class="ident">make_standard_b</span></span>(<span>A_E, A_G, A_L, b_E, b_G, b_L, lb, ub) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>等式制約, 不等式制約から標準形式の right hand side を作成する</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>A_E</code></strong></dt>
<dd>等式制約に関する係数行列</dd>
<dt><strong><code>A_G</code></strong></dt>
<dd>下限制約に関する係数行列</dd>
<dt><strong><code>A_L</code></strong></dt>
<dd>上限制約に関する係数行列</dd>
<dt><strong><code>b_E</code></strong></dt>
<dd>等式制約に関する右辺</dd>
<dt><strong><code>b_G</code></strong></dt>
<dd>下限制約に関する右辺</dd>
<dt><strong><code>b_L</code></strong></dt>
<dd>上限制約に関する右辺</dd>
<dt><strong><code>lb</code></strong></dt>
<dd>変数の下限値</dd>
<dt><strong><code>ub</code></strong></dt>
<dd>変数の上限値. inf であれば上限を設定する必要がない</dd>
</dl></div>
</dd>
<dt id="src.problem.LinearProgrammingProblem.make_standard_c"><code class="name flex">
<span>def <span class="ident">make_standard_c</span></span>(<span>c: np.ndarray, m_GL: int, ub: np.ndarray) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>不等式制約から標準形式の目的関数係数を作成する</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>c</code></strong></dt>
<dd>c</dd>
<dt><strong><code>m_GL</code></strong></dt>
<dd>上限, 下限不等式制約の数を合わせた数</dd>
<dt><strong><code>ub</code></strong></dt>
<dd>変数の上限. 上限が存在しない次元は inf</dd>
</dl></div>
</dd>
<dt id="src.problem.LinearProgrammingProblem.reverse_non_lower_bound"><code class="name flex">
<span>def <span class="ident">reverse_non_lower_bound</span></span>(<span>lb: np.ndarray, ub: np.ndarray, A: np.ndarray, c: np.ndarray) ‑> tuple[numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>変数の下限が存在せず, 上限が存在する場合, 対応する変数の添え字の符号を反転させる</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>lb</code></strong></dt>
<dd>変数の下限. 下限がない次元は -inf</dd>
<dt><strong><code>ub</code></strong></dt>
<dd>変数の上限. 上限がない次元は inf</dd>
<dt><strong><code>A</code></strong></dt>
<dd>A</dd>
<dt><strong><code>c</code></strong></dt>
<dd>c</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>変数の lower bound</dd>
<dt><code>np.ndarray</code></dt>
<dd>変数の upper bound</dd>
<dt><code>np.ndarray</code></dt>
<dd>A. のちにどの制約かによって区分けするが, ここでの出力はひとまとめにしたもの</dd>
<dt><code>np.ndarray</code></dt>
<dd>c</dd>
</dl></div>
</dd>
<dt id="src.problem.LinearProgrammingProblem.separate_free_variable"><code class="name flex">
<span>def <span class="ident">separate_free_variable</span></span>(<span>lb: np.ndarray, ub: np.ndarray, A: np.ndarray, c: np.ndarray) ‑> tuple[numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>変数に下限も上限もない自由変数の場合, 新しい変数列を作成して正の部分と負の部分に分ける</p>
<p>正部分に関する変数は同じ場所に残し, 負部分に関する変数は末尾に追加する
正部分は, 下限を0に変更するのみ
負部分は, 下限0, 上限inf, -A_{正部分}, c_{正部分} をそれぞれ追加する</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>lb</code></strong></dt>
<dd>変数の下限. 下限がない次元は -inf</dd>
<dt><strong><code>ub</code></strong></dt>
<dd>変数の上限. 上限がない次元は inf</dd>
<dt><strong><code>A</code></strong></dt>
<dd>A</dd>
<dt><strong><code>c</code></strong></dt>
<dd>c</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>変数の lower bound</dd>
<dt><code>np.ndarray</code></dt>
<dd>変数の upper bound</dd>
<dt><code>np.ndarray</code></dt>
<dd>A</dd>
<dt><code>np.ndarray</code></dt>
<dd>c</dd>
</dl></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="src.problem.LinearProgrammingProblem.n"><code class="name">prop <span class="ident">n</span></code></dt>
<dd>
<div class="desc"><p>変数の次元数</p>
<p>A_* が空行列となる場合があるため, c の次元から取得</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n(self):
    &#34;&#34;&#34;変数の次元数

    A_* が空行列となる場合があるため, c の次元から取得
    &#34;&#34;&#34;
    return self.c.shape[0]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="src.problem.LinearProgrammingProblem.convert_standard"><code class="name flex">
<span>def <span class="ident">convert_standard</span></span>(<span>self) ‑> <a title="src.problem.problem.LinearProgrammingProblemStandard" href="problem.html#src.problem.problem.LinearProgrammingProblemStandard">LinearProgrammingProblemStandard</a></span>
</code></dt>
<dd>
<div class="desc"><p>等式制約のみの標準形線形計画問題に修正する</p></div>
</dd>
</dl>
</dd>
<dt id="src.problem.LinearProgrammingProblemStandard"><code class="flex name class">
<span>class <span class="ident">LinearProgrammingProblemStandard</span></span>
<span>(</span><span>A: np.ndarray, b: np.ndarray, c: np.ndarray, name: str = '')</span>
</code></dt>
<dd>
<div class="desc"><p>標準形の線形計画問題に関するクラス</p>
<p>以下の問題について定数を格納する
min c.T @ x
s.t.
A @ x = b
x &gt;= 0</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>問題名. デフォルトは空白</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclasses.dataclass
class LinearProgrammingProblemStandard:
    &#34;&#34;&#34;標準形の線形計画問題に関するクラス

    以下の問題について定数を格納する
    min c.T @ x
    s.t.
        A @ x = b
        x &gt;= 0

    Args:
        name: 問題名. デフォルトは空白
    &#34;&#34;&#34;
    A: np.ndarray
    b: np.ndarray
    c: np.ndarray
    name: str = &#34;&#34;

    @property
    def n(self):
        &#34;&#34;&#34;変数の次元数&#34;&#34;&#34;
        return self.A.shape[1]

    @property
    def m(self):
        &#34;&#34;&#34;制約の数&#34;&#34;&#34;
        return self.A.shape[0]

    def __post_init__(self):
        &#34;&#34;&#34;設定された定数の次元が正しいか確認し, 正しくなければエラーを返す&#34;&#34;&#34;
        m = self.m
        if (dim_b := self.b.shape[0]) != m:
            msg = f&#34;制約の次元数が異なります. Aの行数 : {m}, bの次元 : {dim_b}&#34;
            raise SettingProblemError(msg)
        n = self.n
        if (dim_c := self.c.shape[0]) != n:
            msg = f&#34;目的関数の次元数が異なります. Aの列数 : {n}, cの次元 : {dim_c}&#34;
            raise SettingProblemError(msg)

    def __eq__(self, other: object) -&gt; bool:
        &#34;&#34;&#34;要素が `np.array` なので, 標準の __eq__ メソッドだとエラーになる&#34;&#34;&#34;
        is_same_A = np.array_equal(self.A, other.A)
        is_same_b = np.array_equal(self.b, other.b)
        is_same_c = np.array_equal(self.c, other.c)
        return is_same_A and is_same_b and is_same_c

    @property
    def max_abs_A(self) -&gt; float:
        &#34;&#34;&#34;A の係数のうち最大の絶対値を出力&#34;&#34;&#34;
        return np.abs(self.A).max()

    @property
    def min_abs_A_nonzero(self) -&gt; float:
        &#34;&#34;&#34;A の係数のうち最小の絶対値(0は除く)を出力
        &#34;&#34;&#34;
        return np.abs(self.A[self.A != 0]).min()

    @property
    def condition_number_A(self) -&gt; float:
        return np.linalg.cond(self.A)

    @property
    def max_sqrt_eigen_value_AAT(self) -&gt; float:
        eig_val, _ = np.linalg.eig(self.A @ self.A.T)
        return np.max(np.sqrt(eig_val))

    @property
    def min_sqrt_eigen_value_AAT(self) -&gt; float:
        eig_val, _ = np.linalg.eig(self.A @ self.A.T)
        return np.min(np.sqrt(eig_val))

    def is_full_row_rank(self) -&gt; bool:
        &#34;&#34;&#34;制約行列 A が full row rank かを出力

        Returns:
            bool: A が full row rank であれば true
        &#34;&#34;&#34;
        return np.linalg.matrix_rank(self.A) == self.m

    def objective_main(self, x: np.ndarray) -&gt; float:
        &#34;&#34;&#34;主問題の目的関数値の出力&#34;&#34;&#34;
        return self.c.T @ x

    def objective_dual(self, y: np.ndarray) -&gt; float:
        &#34;&#34;&#34;双対問題の目的関数値の出力&#34;&#34;&#34;
        return self.b.T @ y

    def residual_main_constraint(self, x: np.ndarray) -&gt; np.ndarray:
        &#34;&#34;&#34;主問題の制約に対する残渣ベクトルの出力&#34;&#34;&#34;
        return self.A @ x - self.b

    def residual_dual_constraint(
        self, y: np.ndarray, s: np.ndarray
    ) -&gt; np.ndarray:
        &#34;&#34;&#34;双対問題の制約に対する残渣ベクトルの出力&#34;&#34;&#34;
        return self.A.T @ y + s - self.c

    # このメソッドは最適解自体を変えてしまうので削除
    # def create_A_row_normalized(self) -&gt; LinearProgrammingProblemStandard:
    #     &#34;&#34;&#34;A の各行のノルムを 1 に正規化した問題を出力

    #     Returns:
    #         LinearProgrammingProblemStandard: 正規化された問題
    #     &#34;&#34;&#34;
    #     norm_each_row_A = np.linalg.norm(self.A, axis=1)
    #     return LinearProgrammingProblemStandard(self.A / norm_each_row_A[:, None], self.b / norm_each_row_A, self.c, self.name)

    def create_A_LU_factorized(self) -&gt; tuple[LinearProgrammingProblemStandard, list[int]]:
        &#34;&#34;&#34;A をLU分解した問題を出力
        Uの対角成分が0の場合, bの対応する行がすべて0であれば, その行をすべて削除して問題サイズを小さくする
        もし0でなければ実行不可能としてエラーを吐く

        Returns:
            LinearProgrammingProblemStandard: A=U, b=(PL)^(-1) とした問題.
                U の対角成分が0の行は抜いてある
            list[int]: もしUの対角成分が0だった場合にどの行が対象になったかを表す list
        &#34;&#34;&#34;
        P, L, U = scipy.linalg.lu(self.A)
        b_factorized = np.linalg.inv(P) @ np.linalg.inv(L) @ self.b

        # U の対角成分が0の行を記録
        idx_zero_diag_element: list[int] = []
        for i in range(self.m):
            if np.all(np.isclose(U[i, :], 0)):
                if not np.isclose(b_factorized[i], 0):
                    raise SettingProblemError(f&#34;{i}行目において数値誤差を凌駕するほど実行不可能. U_i: {U[i, :]}, b_i: {b_factorized[i]}&#34;)
                idx_zero_diag_element.append(i)

        # 指定された行を省いて出力
        idx_leave_row = np.ones(self.m, dtype=bool)
        idx_leave_row[idx_zero_diag_element] = False
        A_new = U[idx_leave_row, :]
        b_new = b_factorized[idx_leave_row]

        return LinearProgrammingProblemStandard(A_new, b_new, self.c, self.name), idx_zero_diag_element</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="src.problem.LinearProgrammingProblemStandard.A"><code class="name">var <span class="ident">A</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.problem.LinearProgrammingProblemStandard.b"><code class="name">var <span class="ident">b</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.problem.LinearProgrammingProblemStandard.c"><code class="name">var <span class="ident">c</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.problem.LinearProgrammingProblemStandard.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="src.problem.LinearProgrammingProblemStandard.condition_number_A"><code class="name">prop <span class="ident">condition_number_A</span> : float</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def condition_number_A(self) -&gt; float:
    return np.linalg.cond(self.A)</code></pre>
</details>
</dd>
<dt id="src.problem.LinearProgrammingProblemStandard.m"><code class="name">prop <span class="ident">m</span></code></dt>
<dd>
<div class="desc"><p>制約の数</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def m(self):
    &#34;&#34;&#34;制約の数&#34;&#34;&#34;
    return self.A.shape[0]</code></pre>
</details>
</dd>
<dt id="src.problem.LinearProgrammingProblemStandard.max_abs_A"><code class="name">prop <span class="ident">max_abs_A</span> : float</code></dt>
<dd>
<div class="desc"><p>A の係数のうち最大の絶対値を出力</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def max_abs_A(self) -&gt; float:
    &#34;&#34;&#34;A の係数のうち最大の絶対値を出力&#34;&#34;&#34;
    return np.abs(self.A).max()</code></pre>
</details>
</dd>
<dt id="src.problem.LinearProgrammingProblemStandard.max_sqrt_eigen_value_AAT"><code class="name">prop <span class="ident">max_sqrt_eigen_value_AAT</span> : float</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def max_sqrt_eigen_value_AAT(self) -&gt; float:
    eig_val, _ = np.linalg.eig(self.A @ self.A.T)
    return np.max(np.sqrt(eig_val))</code></pre>
</details>
</dd>
<dt id="src.problem.LinearProgrammingProblemStandard.min_abs_A_nonzero"><code class="name">prop <span class="ident">min_abs_A_nonzero</span> : float</code></dt>
<dd>
<div class="desc"><p>A の係数のうち最小の絶対値(0は除く)を出力</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def min_abs_A_nonzero(self) -&gt; float:
    &#34;&#34;&#34;A の係数のうち最小の絶対値(0は除く)を出力
    &#34;&#34;&#34;
    return np.abs(self.A[self.A != 0]).min()</code></pre>
</details>
</dd>
<dt id="src.problem.LinearProgrammingProblemStandard.min_sqrt_eigen_value_AAT"><code class="name">prop <span class="ident">min_sqrt_eigen_value_AAT</span> : float</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def min_sqrt_eigen_value_AAT(self) -&gt; float:
    eig_val, _ = np.linalg.eig(self.A @ self.A.T)
    return np.min(np.sqrt(eig_val))</code></pre>
</details>
</dd>
<dt id="src.problem.LinearProgrammingProblemStandard.n"><code class="name">prop <span class="ident">n</span></code></dt>
<dd>
<div class="desc"><p>変数の次元数</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n(self):
    &#34;&#34;&#34;変数の次元数&#34;&#34;&#34;
    return self.A.shape[1]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="src.problem.LinearProgrammingProblemStandard.create_A_LU_factorized"><code class="name flex">
<span>def <span class="ident">create_A_LU_factorized</span></span>(<span>self) ‑> tuple[<a title="src.problem.problem.LinearProgrammingProblemStandard" href="problem.html#src.problem.problem.LinearProgrammingProblemStandard">LinearProgrammingProblemStandard</a>, list[int]]</span>
</code></dt>
<dd>
<div class="desc"><p>A をLU分解した問題を出力
Uの対角成分が0の場合, bの対応する行がすべて0であれば, その行をすべて削除して問題サイズを小さくする
もし0でなければ実行不可能としてエラーを吐く</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="src.problem.LinearProgrammingProblemStandard" href="#src.problem.LinearProgrammingProblemStandard">LinearProgrammingProblemStandard</a></code></dt>
<dd>A=U, b=(PL)^(-1) とした問題.
U の対角成分が0の行は抜いてある</dd>
<dt><code>list[int]</code></dt>
<dd>もしUの対角成分が0だった場合にどの行が対象になったかを表す list</dd>
</dl></div>
</dd>
<dt id="src.problem.LinearProgrammingProblemStandard.is_full_row_rank"><code class="name flex">
<span>def <span class="ident">is_full_row_rank</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>制約行列 A が full row rank かを出力</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>A が full row rank であれば true</dd>
</dl></div>
</dd>
<dt id="src.problem.LinearProgrammingProblemStandard.objective_dual"><code class="name flex">
<span>def <span class="ident">objective_dual</span></span>(<span>self, y: np.ndarray) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>双対問題の目的関数値の出力</p></div>
</dd>
<dt id="src.problem.LinearProgrammingProblemStandard.objective_main"><code class="name flex">
<span>def <span class="ident">objective_main</span></span>(<span>self, x: np.ndarray) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>主問題の目的関数値の出力</p></div>
</dd>
<dt id="src.problem.LinearProgrammingProblemStandard.residual_dual_constraint"><code class="name flex">
<span>def <span class="ident">residual_dual_constraint</span></span>(<span>self, y: np.ndarray, s: np.ndarray) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>双対問題の制約に対する残渣ベクトルの出力</p></div>
</dd>
<dt id="src.problem.LinearProgrammingProblemStandard.residual_main_constraint"><code class="name flex">
<span>def <span class="ident">residual_main_constraint</span></span>(<span>self, x: np.ndarray) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>主問題の制約に対する残渣ベクトルの出力</p></div>
</dd>
</dl>
</dd>
<dt id="src.problem.SettingProblemError"><code class="flex name class">
<span>class <span class="ident">SettingProblemError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>問題を設定する際に例外が起こったら起こすエラー</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SettingProblemError(Exception):
    &#34;&#34;&#34;問題を設定する際に例外が起こったら起こすエラー&#34;&#34;&#34;
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src" href="../index.html">src</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="src.problem.preprocessor" href="preprocessor.html">src.problem.preprocessor</a></code></li>
<li><code><a title="src.problem.problem" href="problem.html">src.problem.problem</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.problem.LPPreprocessor" href="#src.problem.LPPreprocessor">LPPreprocessor</a></code></h4>
<ul class="">
<li><code><a title="src.problem.LPPreprocessor.find_zero_columns_in_A" href="#src.problem.LPPreprocessor.find_zero_columns_in_A">find_zero_columns_in_A</a></code></li>
<li><code><a title="src.problem.LPPreprocessor.fix_positive_variable_by_signs" href="#src.problem.LPPreprocessor.fix_positive_variable_by_signs">fix_positive_variable_by_signs</a></code></li>
<li><code><a title="src.problem.LPPreprocessor.fix_singleton_by_two_rows" href="#src.problem.LPPreprocessor.fix_singleton_by_two_rows">fix_singleton_by_two_rows</a></code></li>
<li><code><a title="src.problem.LPPreprocessor.fix_variables_by_multiple_rows" href="#src.problem.LPPreprocessor.fix_variables_by_multiple_rows">fix_variables_by_multiple_rows</a></code></li>
<li><code><a title="src.problem.LPPreprocessor.fix_variables_by_single_row" href="#src.problem.LPPreprocessor.fix_variables_by_single_row">fix_variables_by_single_row</a></code></li>
<li><code><a title="src.problem.LPPreprocessor.only_one_nonzero_elements_and_columns" href="#src.problem.LPPreprocessor.only_one_nonzero_elements_and_columns">only_one_nonzero_elements_and_columns</a></code></li>
<li><code><a title="src.problem.LPPreprocessor.remove_duplicated_column" href="#src.problem.LPPreprocessor.remove_duplicated_column">remove_duplicated_column</a></code></li>
<li><code><a title="src.problem.LPPreprocessor.remove_duplicated_row" href="#src.problem.LPPreprocessor.remove_duplicated_row">remove_duplicated_row</a></code></li>
<li><code><a title="src.problem.LPPreprocessor.remove_empty_column" href="#src.problem.LPPreprocessor.remove_empty_column">remove_empty_column</a></code></li>
<li><code><a title="src.problem.LPPreprocessor.remove_empty_row" href="#src.problem.LPPreprocessor.remove_empty_row">remove_empty_row</a></code></li>
<li><code><a title="src.problem.LPPreprocessor.remove_free_variables" href="#src.problem.LPPreprocessor.remove_free_variables">remove_free_variables</a></code></li>
<li><code><a title="src.problem.LPPreprocessor.remove_row_singleton" href="#src.problem.LPPreprocessor.remove_row_singleton">remove_row_singleton</a></code></li>
<li><code><a title="src.problem.LPPreprocessor.rows_only_one_nonzero" href="#src.problem.LPPreprocessor.rows_only_one_nonzero">rows_only_one_nonzero</a></code></li>
<li><code><a title="src.problem.LPPreprocessor.run" href="#src.problem.LPPreprocessor.run">run</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="src.problem.LinearProgrammingProblem" href="#src.problem.LinearProgrammingProblem">LinearProgrammingProblem</a></code></h4>
<ul class="">
<li><code><a title="src.problem.LinearProgrammingProblem.A_E" href="#src.problem.LinearProgrammingProblem.A_E">A_E</a></code></li>
<li><code><a title="src.problem.LinearProgrammingProblem.A_G" href="#src.problem.LinearProgrammingProblem.A_G">A_G</a></code></li>
<li><code><a title="src.problem.LinearProgrammingProblem.A_L" href="#src.problem.LinearProgrammingProblem.A_L">A_L</a></code></li>
<li><code><a title="src.problem.LinearProgrammingProblem.LB" href="#src.problem.LinearProgrammingProblem.LB">LB</a></code></li>
<li><code><a title="src.problem.LinearProgrammingProblem.LB_index" href="#src.problem.LinearProgrammingProblem.LB_index">LB_index</a></code></li>
<li><code><a title="src.problem.LinearProgrammingProblem.UB" href="#src.problem.LinearProgrammingProblem.UB">UB</a></code></li>
<li><code><a title="src.problem.LinearProgrammingProblem.UB_index" href="#src.problem.LinearProgrammingProblem.UB_index">UB_index</a></code></li>
<li><code><a title="src.problem.LinearProgrammingProblem.b_E" href="#src.problem.LinearProgrammingProblem.b_E">b_E</a></code></li>
<li><code><a title="src.problem.LinearProgrammingProblem.b_G" href="#src.problem.LinearProgrammingProblem.b_G">b_G</a></code></li>
<li><code><a title="src.problem.LinearProgrammingProblem.b_L" href="#src.problem.LinearProgrammingProblem.b_L">b_L</a></code></li>
<li><code><a title="src.problem.LinearProgrammingProblem.c" href="#src.problem.LinearProgrammingProblem.c">c</a></code></li>
<li><code><a title="src.problem.LinearProgrammingProblem.convert_standard" href="#src.problem.LinearProgrammingProblem.convert_standard">convert_standard</a></code></li>
<li><code><a title="src.problem.LinearProgrammingProblem.make_standard_A" href="#src.problem.LinearProgrammingProblem.make_standard_A">make_standard_A</a></code></li>
<li><code><a title="src.problem.LinearProgrammingProblem.make_standard_b" href="#src.problem.LinearProgrammingProblem.make_standard_b">make_standard_b</a></code></li>
<li><code><a title="src.problem.LinearProgrammingProblem.make_standard_c" href="#src.problem.LinearProgrammingProblem.make_standard_c">make_standard_c</a></code></li>
<li><code><a title="src.problem.LinearProgrammingProblem.n" href="#src.problem.LinearProgrammingProblem.n">n</a></code></li>
<li><code><a title="src.problem.LinearProgrammingProblem.name" href="#src.problem.LinearProgrammingProblem.name">name</a></code></li>
<li><code><a title="src.problem.LinearProgrammingProblem.reverse_non_lower_bound" href="#src.problem.LinearProgrammingProblem.reverse_non_lower_bound">reverse_non_lower_bound</a></code></li>
<li><code><a title="src.problem.LinearProgrammingProblem.separate_free_variable" href="#src.problem.LinearProgrammingProblem.separate_free_variable">separate_free_variable</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="src.problem.LinearProgrammingProblemStandard" href="#src.problem.LinearProgrammingProblemStandard">LinearProgrammingProblemStandard</a></code></h4>
<ul class="">
<li><code><a title="src.problem.LinearProgrammingProblemStandard.A" href="#src.problem.LinearProgrammingProblemStandard.A">A</a></code></li>
<li><code><a title="src.problem.LinearProgrammingProblemStandard.b" href="#src.problem.LinearProgrammingProblemStandard.b">b</a></code></li>
<li><code><a title="src.problem.LinearProgrammingProblemStandard.c" href="#src.problem.LinearProgrammingProblemStandard.c">c</a></code></li>
<li><code><a title="src.problem.LinearProgrammingProblemStandard.condition_number_A" href="#src.problem.LinearProgrammingProblemStandard.condition_number_A">condition_number_A</a></code></li>
<li><code><a title="src.problem.LinearProgrammingProblemStandard.create_A_LU_factorized" href="#src.problem.LinearProgrammingProblemStandard.create_A_LU_factorized">create_A_LU_factorized</a></code></li>
<li><code><a title="src.problem.LinearProgrammingProblemStandard.is_full_row_rank" href="#src.problem.LinearProgrammingProblemStandard.is_full_row_rank">is_full_row_rank</a></code></li>
<li><code><a title="src.problem.LinearProgrammingProblemStandard.m" href="#src.problem.LinearProgrammingProblemStandard.m">m</a></code></li>
<li><code><a title="src.problem.LinearProgrammingProblemStandard.max_abs_A" href="#src.problem.LinearProgrammingProblemStandard.max_abs_A">max_abs_A</a></code></li>
<li><code><a title="src.problem.LinearProgrammingProblemStandard.max_sqrt_eigen_value_AAT" href="#src.problem.LinearProgrammingProblemStandard.max_sqrt_eigen_value_AAT">max_sqrt_eigen_value_AAT</a></code></li>
<li><code><a title="src.problem.LinearProgrammingProblemStandard.min_abs_A_nonzero" href="#src.problem.LinearProgrammingProblemStandard.min_abs_A_nonzero">min_abs_A_nonzero</a></code></li>
<li><code><a title="src.problem.LinearProgrammingProblemStandard.min_sqrt_eigen_value_AAT" href="#src.problem.LinearProgrammingProblemStandard.min_sqrt_eigen_value_AAT">min_sqrt_eigen_value_AAT</a></code></li>
<li><code><a title="src.problem.LinearProgrammingProblemStandard.n" href="#src.problem.LinearProgrammingProblemStandard.n">n</a></code></li>
<li><code><a title="src.problem.LinearProgrammingProblemStandard.name" href="#src.problem.LinearProgrammingProblemStandard.name">name</a></code></li>
<li><code><a title="src.problem.LinearProgrammingProblemStandard.objective_dual" href="#src.problem.LinearProgrammingProblemStandard.objective_dual">objective_dual</a></code></li>
<li><code><a title="src.problem.LinearProgrammingProblemStandard.objective_main" href="#src.problem.LinearProgrammingProblemStandard.objective_main">objective_main</a></code></li>
<li><code><a title="src.problem.LinearProgrammingProblemStandard.residual_dual_constraint" href="#src.problem.LinearProgrammingProblemStandard.residual_dual_constraint">residual_dual_constraint</a></code></li>
<li><code><a title="src.problem.LinearProgrammingProblemStandard.residual_main_constraint" href="#src.problem.LinearProgrammingProblemStandard.residual_main_constraint">residual_main_constraint</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="src.problem.SettingProblemError" href="#src.problem.SettingProblemError">SettingProblemError</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
